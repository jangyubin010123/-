# CHAPTER 07 > 이진 탐색 : 탐색 범위를 반으로 좁혀가며 빠르게 탐색하는 알고리즘

# <1> 범위를 반씩 좁혀가는 탐색

# "순차 탐색"
# 이진 탐색에 대해 알아보기 전에 가장 기본 탐색 방법인 순차 탐색에 대해 먼저 이해할 필요가 있다.
# "순차 탐색(Sequential Search)"이란 "리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법"이다.
# 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 리스트 내에 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 원소(데이터)를 찾을 수 있다는 장점이 있다.
# 순차 탐색은 이름처럼 순차로 데이터를 탐색한다는 의미이다.
# 리스트 자료형에서 특정한 값을 가지는 원소의 개수를 세는 count() 메서드를 이용할 때도 내부에서는 순차 탐색이 수행된다.
# 순차 탐색을 파이썬 코드로 작성하면 다음과 같다.

# 7-1.py 순차 탐색 소스코드
"""
# 순차 탐색 소스코드 구현
def sequential_search(n, target, array):
    # 각 원소를 하나씩 확인하며
    for i in range(n):
        # 현재의 원소가 찾고자 하는 원소와 동일한 경우
        if array[i] == target:
            return i + 1 # 현재의 위치 반환(인덱스는 0부터 시작하므로 1 더하기)

print("생성할 원소 개수를 입력한 다음 한 칸 띄고 찾을 문자열을 입력하세요.")
input_data = input().split()
n = int(input_data[0]) # 원소의 개수
target = input_data[1] # 찾고자 하는 문자열

print("앞서 적은 원소 개수만큼 문자열을 입력하세요. 구분은 띄어쓰기 한 칸으로 합니다.")
array = input().split()

# 순차 탐색 수행 결과 출력
print(sequential_search(n, target, array))
"""
# 이처럼 순차 탐색은 데이터 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 한다는 점이 특징이다.
# 따라서 데이터의 개수가 N개일 때 최대 N번의 비교 연산이 필요하므로 순차 탐색의 최악의 경우 시간 복잡도는 O(N)이다.

# "이진 탐색 : 반으로 쪼개면서 탐색하기"
# 드디어 본론인 이진 탐색을 공부해보자.
# "이진 탐색(Binary Search)"은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘이다.
# 데이터가 무작위일 때는 사용할 수 없지만, 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다는 특징이 있다.
# 이진 탐색은 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다.
# 이진 탐색은 위치를 나타내는 변수 3개를 사용하는데 탐색하고자 하는 범위의 "시작점, 끝점", 그리고 "중간점"이다.
# "찾으려는 데이터와 중간점(Middle) 위치에 있는 데이터를 반복적으로 비교"해서 원하는 데이터를 찾는게 이진 탐색 과정이다.
# 이진 탐색은 한 번 확인할 때마다 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 시간 복잡도가 O(logN)이다.
# 절반씩 데이터를 줄어들도록 만든다는 점은 앞서 다룬 퀵 정렬과 공통점이 있다.
# 간단히 부가 설명을 하자면, 이진 탐색 알고리즘은 한 단계를 거칠 때마다 확인하는 원소가 평균적으로 절반으로 줄어든다.
# 예를 들어 데이터의 개수가 32개일 때, 1단계만 거치면 이상적인 경우 16개가량의 데이터만 남게 될 것이다.
# 2단계를 거치면 8개가량의 데이터만 확인하면 될 것이다.
# 즉, 단계마다 2로 나누는 것과 동일하므로 연산 횟수는 log2(N)에 비례한다고 할 수 있다. 이는 빅오 표기법에 따라서 간단히 O(logN)이라고 작성한다.
# '이진 탐색을 구현하는 방법'에는 '2가지'가 있는데 -->> 하나는 '재귀 함수'를 이용하는 방법이고, -->> 다른 하나는 단순하게 '반복문'을 이용하는 방법이다.
# 먼저 재귀 함수를 이용한 코드를 보자.

# 7-2.py 재귀 함수로 구현한 이진 탐색 소스코드
"""
# 이진 탐색 소스코드 구현(재귀 함수)
def binary_search(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2
    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target:
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)

# n(원소의 개수)과 target(찾고자 하는 타겟)을 입력받기
n, target = list(map(int, input().split()))
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
"""
# mid = (start + end) // 2는 중간점을 의미한다. 2로 나눈 몫만 구하기 위해 몫 연산자(//)를 사용한 것이다.
# 앞서 그리디 부분에서 '큰 수의 법칙' 문제를 풀 때에는 나눈 뒤에 몫을 구하기 위해 int() 함수를 이용했다.
# 기능 면에서는 두 코드 모두 나눈 몫을 구하는 코드이다. 이처럼 같은 기능이라고 하더라도 다양한 방법으로 구현이 가능하다는 점을 기억하자.
# 다음은 단순하게 '반복문'을 사용한 코드이다. 실행 결과는 재귀 함수와 같으므로 생략한다.

# 7-3.py 반복문으로 구현한 이진 탐색 소스코드
"""
# 이진 탐색 소스코드 구현(반복문)
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        elif array[mid] < target:
            start = mid + 1
    return None

# n(원소의 개수)과 target(찾고자 하는 타겟)을 입력받기
n, target = list(map(int, input().split()))
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
"""

# "코딩 테스트에서의 이진 탐색"
# 단순히 앞의 코드를 보고 이진 탐색이 단순하다고 느낄 수 있지만, 정작 참고할 소스코드가 없는 상태에서 이진 탐색의 소스코드를 구현하는 것은 상당히 어려운 작업이 될 수 있다.
# 존 벤틀리의 말에 따르면 제대로 이진 탐색 코드를 작성한 프로그래머는 10% 내외라 할 정도로 실제 구현은 까다롭다.
# 코드가 짧으니 이진 탐색을 처음 접한 독자라면, 여러 차례 코드를 입력하며 자연스럽게 외워보자.
# 이진 탐색은 코딩 테스트에서 단골로 나온 문제이니 가급적 외우길 바란다.
# 이진 탐색의 원리는 다른 알고리즘에서도 폭넓게 적용되는 원리와 유사하기 때문에 매우 중요하다.
# 또, 높은 난이도의 문제에서는 이진 탐색 알고리즘이 다른 알고리즘과 함께 사용되기도 한다.
# 예를 들어 대회에서 '그리디 알고리즘'과 '이진 탐색 알고리즘'을 모두 사용해서 풀어야 하는 문제가 출제된 적이 있는데, 이런 문제는 난이도가 상당히 높은 데다가 구현할 코드량이 많아 실수하기 쉽다.
# 이때 이진 탐색 코드만 암기하고 있어도 꽤 도움이 된다.
# -->> "더불어 코딩 테스트의 이진 탐색 문제는 탐색 범위가 큰 상황에서의 탐색을 가정하는 문제가 많다. 따라서 탐색 범위가 2,000만을 넘어가면 이진 탐색으로 문제에 접근해보길 권한다."
# 처리해야할 데이터의 개수나 값이 1,000만 단위 이상으로 넘어가면 이진 탐색과 같이 O(logN)의 속도를 내야 하는 알고리즘을 떠올려야 문제를 풀 수 있는 경우가 많다는 점을 기억하자.

# "트리 자료구조"
# 이진 탐색은 전제 조건이 데이터 정렬이다.
# 데이터베이스는 내부적으로 대용량 데이터 처리에 적합한 트리(Tree) 자료구조를 이용하여 항상 데이터가 정렬되어 있다.
# 따라서 데이터베에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어서 데이터가 많아도 탐색하는 속도가 빠르다.
# 그렇다면 트리 자료구조가 무엇인지 간단하게 살펴보자.
# 트리 자료구조는 그래프 자료구조의 일종으로 데이터베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용된다.
# 트리 자료구조는 몇가지 주요한 특징이 있다.
# ....
# * 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.
# 정리하자면 큰 데이터를 처리하는 소프트웨어는 대부분 데이터를 트리 자료구조로 저장해서 이진 탐색과 같은 탐색 기법을 이용해 빠르게 탐색이 가능하다.
# 그렇다면 이런 트리 구조를 이용하면 정확히 어떤 방식으로 항상 이진 탐색이 가능한 걸까?

# "이진 탐색 트리"
# 트리 자료구조 중에서 가장 간단한 형태가 이진 탐색 트리이다.
# 이진 탐색 트리란 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.
# 이진 탐색 트리를 설명하는 동안 코드를 배제할 테니 편하게 다음 그림을 보자.
# ....
# 이진 탐색 트리는 다음과 같은 특징을 가진다.
# * 부모 노드보다 왼쪽 자식 노드가 작다.
# * 부모 노드보다 오른쪽 자식 노드가 크다.
# 좀 더 간단하게 표현하면 "왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드"가 성립해야지 이진 탐색 트리라 할 수 있다.
# 그림에서도 17 < 30 < 48로 성립한다는 걸 알 수 있다.
# 이진 탐색 트리에 데이터를 넣고 빼는 방법은 알고리즘보다는 자료구조에 가까우며, 이진 탐색 트리 자료구조를 구현하도록 요구하는 문제는 출제 빈도가 낮으므로,
# 이 책에서는 이진 탐색 트리를 구현하는 방법은 소개하지 않는다.
# -->> "따라서 이진 탐색 트리가 미리 구현되어 있다고 가정하고 다음 그림과 같은 '이진 탐색 트리에서 데이터를 조회하는 과정'만 살펴보겠다."
# ....
# 이진 탐색 트리에서 데이터 조회는 동작 원리만 살펴보면 간단하게 느껴진다. 공식에 따라 루트 노드부터 왼쪽 자식 노드 혹은 오른쪽 자식 노드로 이동하며
# 반복적으로 방문한다. 자식 노드가 없을 때까지 원소를 찾지 못했다면, 이진 탐색 트리에 원소가 없는 것이다.
# 짧게 3단계로 살펴봤지만 아무리 노드가 많아도 이진 탐색 트리는 이 과정을 반복하는 것에 불과하니 위의 과정 그림을 이해하면 충분하다.

# "빠르게 입력받기"
# 이진 탐색 문제는 입력 데이터가 많거나, 탐색 범위가 매우 넓은 편이다.
# -->> "예를 들어 데이터의 개수가 1,000만 개를 넘어가거나 탐색 범위의 크기가 1,000억 이상이라면 이진 탐색 알고리즘을 의심해보자."
# 그런데 이렇게 입력 데이터의 개수가 많은 문제에 input() 함수를 사용하면 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있다.
# -->> "이처럼 입력 데이터가 많은 문제는 sys 라이브러리의 readline() 함수를 이용하면 시간 초과를 피할 수 있다."
# 때로는 코딩 테스트 출제자가 아예 sys 라이브러리를 사용하기를 권고하는 문장을 문제에 적어 놓기도 한다.
# sys 라이브러리는 다음과 같은 방식으로 사용하며 한 줄씩 입력받는다.

# 7-4.py 한 줄 입력받아 출력하는 소스코드
"""
import sys
# 하나의 문자열 데이터 입력받기
input_data = sys.stdin.readline().rstrip()

# 입력받은 문자열 출력하기
print(input_data)
"""
# sys 라이브러리를 사용할 때는 한 줄 입력받고 나서 rstrip() 함수를 꼭 호출해야 한다.
# 소스코드에 readline()으로 입력하면 입력 후 엔터(Enter)가 줄 바꿈 기호로 입력되는데, 이 공백 문자를 제거하려면 rstrip() 함수를 사용해야 한다.
# 코드가 짧으니, 관행적으로 외워서 사용하자. 또한 readline() 함수를 더 간결하게 사용하는 팁은 부록에서 추가로 다루고 있다.
# 이제 실전 예제를 풀어보며 이진 탐색을 어떻게 사용하는지 알아보자.

# <2> 부품 찾기 

# my solution -->> 예상 시간 복잡도 : O(NlogN + M*logN) -->> "O((M+N)logN)" -->> ok..!!
"""
n = int(input())
store = list(map(int, input().split()))

m = int(input())
request = list(map(int, input().split()))

store.sort() # 동빈이네 전자 매장에 있는 각 부품의 고유번호들(정수 형태)를 오름차순 정렬 시행..!!

def binary_search(store, target, start, end): # 참고 > 여기서 start, end가 의미하는 바는 각각 시작점의 인덱스 값과 끝점의 인덱스 값입니다..!!
    while start <= end:
        mid = (start + end) // 2
        if store[mid] == target:
            return True
        elif store[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return False

for rq in request:
    if binary_search(store, rq, 0, n - 1) == True:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# 문제 해설
# 이 문제는 여러 방법으로 해결할 수 있다. 여기서는 가장 먼저 '이진 탐색 알고리즘'으로 풀이할 텐데, 이처럼 다량의 데이터 검색은 이진 탐색 알고리즘을 이용해 효과적으로 처리할 수 있다.
# 먼저 매장 내 N개의 부품을 번호를 기준으로 정렬하자. 그 이후에 M개의 찾고자 하는 부품이 각각 매장에 존재하는지 검사하면 된다.
# 이때 매장의 부품들은 정렬되어 있기 때문에 이진 탐색을 수행하여 찾을 수 있다.
# 따라서 이렇게 문제를 풀면, 부품을 찾는 과정에서 최악의 경우 시간 복잡도 O(M * logN)의 연산이 필요하므로 이론상 최대 약 200만 번의 연산이 이루어진다고 분석할 수 있다.
# 오히려 N개의 부품을 정렬하기 위해서 요구되는 시간 복잡도 O(N * logN)이 이론적으로 최대 약 2,000만으로 더욱더 많은 연산이 필요한 것을 알 수 있다.
# 결과적으로 이진 탐색을 사용하는 문제 풀이 방법의 경우 시간 복잡도는 O((M + N) * logN)이다.
# 우리가 지금까지 배운 이진 탐색 알고리즘을 이용한 풀이는 다음 소스코드와 같다.

# 7-5.py 답안 예시(이진 탐색)
"""
# 이진 탐색 소스코드 구현(반복문)
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1
    return None

# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력
array = list(map(int, input().split()))
array.sort() # 이진 탐색을 수행하기 위해 사전에 정렬 수행
# M(손님이 확인 요청한 부품 개수) 입력
m = int(input())
# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력
x = list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인
for i in x:
    # 해당 부품이 존재하는지 확인
    result = binary_search(array, i, 0, n - 1)
    if result != None:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# 이진 탐색 말고도 '계수 정렬'의 개념을 이용하여 문제를 풀 수 있다. 모든 원소의 번호를 포함할 수 있는 크기의 리스트를 만든 뒤에, 리스트의 인덱스에 직접 접근하여 특정한 번호의 부품이 매장에 존재하는지 확인하면 된다.

# 7-6.py 답안 예시(계수 정렬)
"""
# N(가게의 부품 개수)을 입력받기
n = int(input())
array = [0] * 1000001

# 가게에 있는 전체 부품 번호를 입력받아서 기록
for i in input().split():
    array[int(i)] += 1 # <==> or we can write that "array[int(i)] = 1"

# M(손님이 확인 요청한 부품 개수)을 입력받기
m = int(input())
# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력
x = list(map(int, input().split()))
# 손님이 확인 요청한 부품 번호를 하나씩 확인
for i in x:
    if array[i] != 0:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# 또는 이 문제는 단순히 특정한 수가 한 번이라도 등장했는지를 검사하면 되므로 집합 자료형을 이용해서 문제를 해결할 수 있다.
# set() 함수는 집합 자료형을 초기화할 때 사용한다. 이러한 집합 자료형은 단순히 특정한 데이터가 존재하는지 검사할 때에 매우 효과적으로 사용할 수 있다.
# 다음의 소스코드가 간결한 측면에서는 가장 우수하다.

# 7-7.py 답안 예시(집합 자료형 이용)
"""
# N(가게의 부품 개수)을 입력받기
n = int(input())
# 가게에 있는 전체 부품 번호를 입력받아서 집합(set) 자료형에 기록
array_set = set(map(int, input().split()))

# M(손님이 확인 요청한 부품 개수)을 입력받기
m = int(input())
# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력
x = list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인
for i in x:
    # 해당 부품이 있는지 확인
    if i in array_set:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# 하지만 이진 탐색으로도 충분히 풀 수 있으며, 경험이 많지 않으면 이진 탐색을 이용한 해법보다는 집합 자료형을 이용한 해법을 떠올리기 어려울 수 있고,
# 혹은 그 반대일 수 있다.
# 따라서 동일한 문제를 여러 가지 방법을 풀 수 있으며, 이 문제는 3가지 방법을 이용해 모두 효과적으로 풀 수 있다는 점을 기억하자.

# <3> 떡복이 떡 만들기

# my solution
"""
# my thoughts : 입력 예시에 나타난 예시를 기준으로 살펴보면 결괏값으로 가능한 절단기의 높이는 0에서 max(array)가 될 것이다.
# 즉, 0 ~ max(array)의 범위 내에서 "이진 탐색"을 계속해서 실행하면서 잘린 떡볶이 길이의 총합이 >=M이 되는 경우에는 계속해서 값을 저장하고 <M가 되는 상황일 때는 반복문을 탈출하여 .... -->> 결괏값을 출력하는 식으로 소스코드를 구현해보기로 하였다..!!
n, m = list(map(int, input().split()))
array = list(map(int, input().split()))
height = list(range(0, max(array) + 1))
# print(height) -->> 출력 결과 Ex : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
#                                  [0] [1] [2] ....
def binary_search(height, target, start, end):
    answer = 0
    while start <= end:
        mid = (start + end) // 2
        sums = sum([num - height[mid] if num >= height[mid] else 0 for num in array])
        if sums == target: # <<-- 이 구문을 만족한다는 뜻은 더 이상 다른 경우는 고려할 필요가 없는 최적의 상황이므로 return문을 넣어줍시다..!!
            answer = height[mid]
            return answer
        elif sums > target: # <<-- 문제의 조건을 만족하는 상황이므로 일단 answer 변수에 값을 대입하고 혹시 모를 상황을 대비해 "start = mid + 1"처리를 해줌으로써 다른 경우를 한 번 더 확인하도록 해줍시다..!!
            answer = height[mid]
            start = mid + 1
        elif sums < target: # <<-- 이 구문을 만족한다는 뜻은 절단기의 높이가 너무 높은 상황이므로 "end = mid - 1"처리를 해줌으로 인해 절단기의 높이를 낮춤으로써 더 많은 떡볶이들이 잘리도록 해줍시다..!! -->> 그래야만 sums의 값이 커질 것이기 때문입니다..!!
            end = mid - 1
    return answer

print(binary_search(height, m, 0, max(array)))
"""
# 문제 해설
# -->> "전형적인 '이진 탐색 문제'이자, '파라메트릭 서치(Parametric Search)유형의 문제'이다."
# 파라메트릭 서치는 최적화 문제를 결정 문제(-->> "결정 문제는 '예' 혹은 '아니요'로 답하는 문제를 말한다.")로 바꾸어 해결하는 기법이다.
# '원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제'에 주로 파라메트릭 서치를 이용한다.
# 예를 들어 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진 탐색으로 결정 문제를 해결하면서 범위를 좁혀갈 수 있다.
# 코딩 테스트나 프로그래밍 대회에서는 보통 파라메트릭 서치 유형은 이진 탐색을 이용하여 해결한다.
# -->> "이 문제의 풀이 아이디어는 의외로 간단한데 적절한 높이를 찾을 때까지 절단기의 높이 H를 반복해서 조정하는 것이다."
# 그래서 '현재 이 높이로 자르면 조건을 만족할 수 있는가?'를 확인한 뒤에 조건의 만족 여부('예' 혹은 '아니요')에 따라서 탐색 범위를 좁혀서 해결할 수 있다.
# 범위를 좁힐 때는 이진 탐색의 원리를 이용하여 절반씩 탐색 범위를 좁혀 나간다.
# 절단기의 높이(탐색 범위)는 1부터 10억까지의 정수 중 하나인데, -->> "이처럼 큰 수를 보면 당연하다는 듯이 가장 먼저 이진 탐색을 떠올려야 한다."
# 이 문제에서 절단기의 높이 범위가 한정적이었다면 순차 탐색으로도 해결할 수 있지만, 현재 문제에서 절단기의 높이는 최대 10억까지의 정수이므로 순차 탐색은 분명 시간 초과를 받을 것이다.
# -->> "반면에 높이 H를 '이진 탐색'으로 찾는다면, 대략 31번 만에 경우의 수를 모두 고려할 수 있다. 이때 떡의 개수 N이 최대 100만 개이므로 이진 탐색으로 절단기의 높이 H를 바꾸면서, 바꿀 때마다 모든 떡을 체크하는 경우 대략 최대 3,000만 번 정도의 연산으로 문제를 풀 수 있다."
# 문제의 시간 제한은 2초이므로 최악의 경우 3,000만 번 정도의 연산이 필요하다면 아슬아슬하게 시간 초과를 받지 않고 정답 판정을 받을 것이다.
# (ex) .... 당연하지만, 절단기의 높이는 H는 0부터 가장 긴 떡의 길이 안에 있어야만 떡을 자를 수 있다.
# ....
# -->> "이러한 이진 탐색 과정을 반복하면 답을 도출할 수 있다. 중간점의 값은 시간이 지날수록 '최적화된 값'을 찾기 때문에, 과정을 반복하면서 얻을 수 있는 떡의 길이 합이 필요한 떡의 길이보다 크거나 같을 때마다 결괏값을 중간점(MID) 값으로 갱신해주면 된다."
# -->> "또한 이 문제에서는 현재 얻을 수 있는 떡볶이 양에 따라서 자를 위치를 결정해야 하기 때문에 이를 재귀적으로 구현하는 것은 귀찮은 작업이 될 수 있다."
# -->> '따라서 일반적으로 이 문제와 같은 파라메트릭 서치 문제 유형은 -->> "이진 탐색을 재귀적(x)으로 구현하지 않고 반복문(o)을 이용해 구현하면 더 간결하게 풀 수 있다."'
# 전체 소스코드는 다음과 같다.

# 7-8.py 답안 예시

# 떡의 개수(N)와 요청한 떡의 길이(M)을 입력받기
n, m = list(map(int, input().split()))
# 각 떡의 개별 높이 정보를 입력받기
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행(반복적)
result = 0
while start <= end:
    total = 0
    mid = (start + end) // 2
    for x in array:
        # 잘랐을 때 떡의 양 계산
        total += x - mid if x >= mid else 0
    # 떡의 양이 부족한 경우 더 많이 자르기(왼쪽 부분 탐색)
    if total < m:
        end = mid - 1
    # 떡의 양이 충분한 경우 덜 자르기(오른쪽 부분 탐색)
    else:
        result = mid # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록(-->> 즉, 여기 구문 올때마다 result 변수에 mid 값을 대입해줍시다..!!)
        start = mid + 1

# 정답 출력
print(result)
