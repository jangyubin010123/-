# CHAPTER 05 > DFS/BFS : 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘

# <1> 꼭 필요한 자료구조 기초

# 탐색(Search)이란 "많은 양의 데이터 중에서 원하는 데이터를 찾는 과정"을 의미한다.
# 프로그래밍에서는 '그래프', '트리' 등의 '자료구조' 안에서 '탐색'을 하는 문제를 자주 다룬다.
# 대표적인 탐색 알고리즘으로 DFS 와 BFS를 꼽을 수 있는데, 이 두 알고리즘의 원리를 제대로 이해해야 코딩 테스트의 탐색 문제 유형을 풀 수 있다.
# 그런데 DFS 와 BFS를 제대로 이해하려면 기본 자료구조인 스택과 큐에 대한 이해가 전제되어야 하므로 사전 학습으로 스택과 큐, 재귀 함수를 간단히 정리하고자 한다.
# 자료구조(Data Structure)란 "데이터를 표현하고 관리하고 처리하기 위한 구조"를 의미한다.
# 그중 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.
# * 삽입(Push) : 데이터를 삽입한다.
# * 삭제(Pop) : 데이터를 삭제한다.
# -->> "물론 실제 스택과 큐를 사용할 때는 삽입과 삭제 외에도 '오버플로'와 '언더플로'를 고민해야 한다."
# "오버플로(Overflow)"는 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 상태에서 삽입 연산을 수행할 때 발생한다.
# 즉, 저장 공간을 벗어나 데이터가 넘쳐흐를 때 발생한다.
# 반면에 특정한 자료구조에 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행하면 데이터가 전혀 없는 상태이므로 언더플로(Underflow)가 발생한다.

# "스택"
# "스택(Stack)"은 박스 쌓기에 비유할 수 있다.
# ....
# 이러한 구조를 "선입후출(Fisrt In Last Out)구조 또는 후입선출(Last In First Out)구조"라고 한다.
# ....
# 이를 파이썬 코드로 표현하면 다음과 같다.

# 5-1.py 스택 예제
"""
stack = []

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack) # 최하단 원소부터 출력
print(stack[-1::-1]) # 최상단 원소부터 출력
"""
# 파이썬에서 스택을 이용할 때에는 별도의 라이브러리를 사용할 필요가 없다. 기본 리스트에서 append()와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작한다.
# append() 메서드는 리스트의 가장 뒤쪽에 원소를 삽입하고, pop() 메서드는 리스트의 가장 뒤쪽에서 데이터를 꺼내기 때문이다.

# "큐"
# 큐(Queue)는 대기 줄에 비유할 수 있다. ....
# 때문에 흔히 '공정한' 자료구조라고 비유된다.
# 이러한 구조를 "선입선출(First In First Out)구조"라고 한다.
# ....
# 이를 파이썬 코드로 표현하면 다음과 같다. 큐의 앞쪽 원소부터 출력하는 코드와 뒤쪽 원소부터 출력하는 내용을 모두 포함하였다.

# 5-2.py 큐 예제
"""
from collections import deque

# 큐(Queue) 구현을 위해 deque 라이브러리 사용
queue = deque()

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
# 출력 결과 : deque([3, 7, 1, 4])
queue.reverse() # 다음 출력을 위해 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력
# 출력 결과 : deque([4, 1, 7, 3])
"""
# 파이썬으로 큐를 구현할 때는 collections 모듈에서 제공하는 deque 자료구조를 활용하자.
# -->> "deque는 스택과 큐의 장점을 모두 채택한 것인데 데이터를 넣고 빼는 속도가 리스트 자료형에 비해 효율적이며
# queue 라이브러리를 이용하는 것보다 더 간단하다."
# -->> "더불어 대부분의 코딩 테스트에서는 collections 모듈과 같은 기본 라이브러리 사용을 허용하므로 안심하고 사용해도 괜찮다."
# 자세한 내용은 부록 A의 파이썬 문법 파트에서 확인할 수 있다.
# 또한 deque 객체를 리스트 자료형으로 변경하고자 한다면 list() 메서드를 활용하자.
# 이 소스코드에서는 list(queue)를 하면 리스트 자료형이 반환된다.

# "재귀 함수"
# -->> "DFS와 BFS를 구현하려면 재귀 함수도 이해하고 있어야 한다."
# "재귀 함수(Recursive Function)"란 "자기 자신을 다시 호출하는 함수"를 의미한다. 가장 간단한 재귀 함수는 다음과 같다.

# 5-3.py 재귀 함수 예제
"""
def recursive_function():
    print("재귀 함수를 호출합니다.")
    recursive_function()

print(recursive_function())
"""
# .... 물론 어느 정도 출력하다가 다음과 같은 오류 메시지를 출력하고 멈출 것이다.

# -->> "RecursionError: maximum recursion depth exceeded while calling a Python object"

# -->> "이 오류 메시지는 재귀(Recursion)의 최대 깊이를 초과했다는 내용이다."
# 보통 파이썬 인터프리터는 호출 횟수 제한이 있는데 이 한계를 벗어났기 때문이다.
# 따라서 무한대로 재귀 호출을 진행할 수느 없다.(애초에 무한한 재귀 호출을 요구하는 문제 또한 출제되지 않을 것이다.)

# "재귀 함수의 종료 조건"
# 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해줘야 한다.
# 자칫 종료 조건을 명시하지 않으면 함수가 무한 호출될 수 있다.
# 예를 들어 다음은 재귀 함수를 100번 호출하도록 작성한 코드이다.
# 재귀 함수 초반에 등장하는 if문이 종료 조건 역할을 수행한다.

# 5-4.py 재귀 함수 종료 예제
"""
def recursive_function(i):
    # 100번 째 출력했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return 
    
    print(i, "번째 재귀 함수에서", i + 1, "번째 재귀 함수를 호출합니다.")
    recursive_function(i + 1)
    print(i, "번째 재귀 함수를 종료합니다.")

recursive_function(1)
"""
# 컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.
# -->> "컴퓨터의 구조 측면에서 보자면 연속해서 호출되는 함수는 메인 메모리의 스택 공간에 적재되므로 재귀 함수는 스택 자료구조와 같다는 말은 틀린 말이 아니다."
# 컴퓨터 구조는 이 책의 범위를 벗어나니 컴퓨터 구조 이야기는 잊고, -->> "재귀 함수는 내부적으로 스택 자료구조와 동일하다는 것만 기억하자."
# -->> "따라서 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현될 수 있다."
# DFS가 대표적인 예이다.
# 재귀 함수를 이용하는 대표적인 예제로는 팩토리얼(Factorial)문제가 있다.
# ....
# 팩토리얼을 '반복적'으로 구현한 방식과 '재귀적'으로 구현한 두 방식을 비교해보자.
# 소스코드는 다음과 같다.

# 5-5.py 2가지 방식으로 구현한 팩토리얼 예제
"""
# 반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    # 1부터 n까지의 수를 차례대로 곱하기
    for i in range(1, n + 1):
        result *= i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):
    if n <= 1: # n이 1 이하인 경우 1을 반환
        return 1
    # n! = n * (n - 1)!를 그대로 코드로 작성하기
    return n * factorial_recursive(n - 1)

# 각각의 방식으로 구현한 n! 출력(n = 5)
print("반복적으로 구현:", factorial_iterative(5))
print("재귀적으로 구현:", factorial_recursive(5))
# 출력 결과 : 반복적으로 구현: 120
# 출력 결과 : 재귀적으로 구현: 120
"""
# 실행 결과는 동일하다. 그렇다면 반복문 대신에 재귀 함수를 이용했을 때 얻을 수 있는 장점은 무엇인가?
# 위의 코드를 비교했을 때 재귀 함수의 코드가 더 간결한 것을 알 수 있다.
# 이렇게 간결해진 이유는 재귀 함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문이다.
# 수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미한다.
#  -->> "이 개념은 이후에 배울 8장의 "다이나믹 프로그래밍"으로 이어지기 때문에 중요하다."

# <2> 탐색 알고리즘 DFS / BFS

# 스택과 큐, 재귀 함수는 DFS와 BFS에서 가장 중요한 개념이라 DFS/BFS를 배우기에 앞서 간단하게 설명했다.
# 이제부터 DFS/BFS 알고리즘을 살펴보겠다.

# "DFS"
# "DFS"는 Depth-First Search, "깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분은 우선적으로 탐색하는 알고리즘"이다.
# DFS를 설명하기 전에 먼저 그래프(Graph)의 기본 구조를 알아야 한다.
# 그래프는 "노드(Node)"와 "간선(Edge)"으로 표현되며 이때 노드를 "정점(Vertex)"이라고도 말한다.
# ....
# -->> "프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데" -->> "코딩 테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고 있도록 하자."
# * 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
# * 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식
# 먼저 "인접 행렬(Adjacency Matrix)방식"은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다.
# 위와 같이 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트로 구현할 수 있다.
# 연결이 되어 있지 않은 노드끼리는 무한(Infinity)의 비용이라고 작성한다.
# 실제 코드에서는 논리적을 정답이 될 수 없는 큰 값 중에서 999999999, 987654321 등의 값을 초기화하는 경우가 많다.
# 이렇게 그래프를 인접 행렬 방식으로 처리할 때는 다음과 같이 데이터를 초기화한다.

# 5-6.py 인접 행렬 방식 예제
"""
INF = 999_999_999 # 무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
"""
# 그렇다면 "인접 리스트(Adjacency List) 방식"에서는 데이터를 어떤 방식으로 저장할까?
# 인접 리스트 방식에서는 다음 그림처럼 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.
# 인접 리스트는 "연결 리스트"라는 자료구조를 이용해 구현하는데,
# C++나 자바와 같은 프로그래밍 언어에서는 별도로 연결 리스트 기능을 위한 표준 라이브러리를 제공한다.
# 반면에 파이썬은 기본 자료형인 리스트 자료형이 append()와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 기본으로 제공한다.
# 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점만 기억하자.
# 다음은 예제 그래프를 인접 리스트 방식으로 처리할 때 데이터를 초기화한 코드이다.

# 5-7.py 인접 리스트 방식 예제
"""
# 행(Row)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
"""
# 이 두 방식은 어떤 차이가 있을까? 코딩 테스트를 위해 학습하는 터라 메모리와 속도 측면에서 살펴보겠다.
# 메모리 측면에서 보자면 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.
# 반면에 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
# 하지만 이와 같은 속성 때문에 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다.
# 인접 리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.
# 또 다른 예시로 한 그래프에서 노드 1과 노드 7이 연결되어 있는 상황을 생각해보자.
# 인접 행렬 방식에서는 graph[1][7]만 확인하면 된다.
# 반면에 인접 리스트 방식에서는 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인해야 한다.
# -->> "그러므로 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다."
# DFS는 깊이 우선 탐색이라고 했다. 이 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후,
# 다시 돌아가 다른 경로를 탐색하는 알고리즘이다.
# -->> "DFS는 스택 자료구조를 이용하며 구체적인 동작 과정은 다음과 같다."
# ..................................................................
# 1. 탐색 시작 노드를 스택에 넣고 방문 처리를 한다.
# 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
# 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
# ..................................................................
# 다음과 같은 그래프를 생각해보자. 노드 1을 시작 노드로 설정하여 DFS를 이용해 탐색을 진행하면 어떻게 될까?
# 직관적으로 생각하면, 깊이 우선 탐색이라는 이름에서부터 알 수 있듯이 단순하게 가장 깊숙이 위치하는 노드에 닿을 때까지 확인(탐색)하면 된다.
# ....
# DFS를 이용하여 탐색하면 그 과정은 다음과 같다. 또한 일반적으로 인접한 노드 중에서 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리한다.
# <TIP> DFS의 기능을 생각하면 순서와 상관없이 처리해도 되지만, 코딩 테스트에서는 번호가 낮은 순서부터 처리하도록 명시하는 경우가 종종 있다.
# 따라서 관행적으로 번호가 낮은 순서부터 처리하도록 구현하는 편이다.
# ....
# ....
# ....
# 결과적으로 노드의 탐색 순서(스택에 들어간 순서)는 다음과 같다.
# -->> "1 -->> 2 -->> 7 -->> 6 --> 8 -->> 3 -->> 4 -->> 5"
# -->> 깊이 우선 탐색 알고리즘인 DFS는 스택 자료구조에 기초한다는 점에서 구현이 간단하다.
# -->> 실제로는 스택을 쓰지 않아도 되며 탐색을 수행함에 있어서 데이터의 개수가 N개일 경우, O(N)의 시간이 소요된다는 특징이 있다.
# -->> "또한 DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀 함수를 이용했을 때 매우 간결하게 구현할 수 있다."
# 예제 소스코드는 다음과 같다.

# 5-8.py DFS 예제 
"""
# DFS 메서드 정의
def dfs(graph, start_v, visited):
    # 현재 노드를 방문 처리
    visited[start_v] = True
    print(start_v, end = " ")
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[start_v]:
        if not visited[i]:
            dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
"""

# "BFS"
# "BFS(Breadth First Search)"알고리즘은 "너비 우선 탐색"이라는 의미를 가진다.
# 쉽게 말해 "가까운 노드부터 탐색하는 알고리즘"이다.
# DFS는 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다고 했는데, BFS는 그 반대다.
# 그렇다면 BFS는 실제로 어떤 방식으로 구현할 수 있을까?
# BFS 구현에서는 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.
# 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.
# 그림과 함께 자세한 동작 방식을 살펴보자.
# 알고리즘의 정확한 동작 방식은 다음과 같다.
# ...........................................
# 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
# 2. 큐에서 노드 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
# 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
# 오른쪽과 같은 그래프를 생각해보자.
# BFS를 이용하여 탐색하면 그 과정은 다음과 같다.
# 마찬가지로 인접한 노드가 여러 개 있으면, 숫자가 작은 노드부터 먼저 큐에 삽입한다고 가정한다.
# 다음 그림에서 큐에 원소가 들어올 때, 위에서 들어오고 아래쪽에서 꺼낸다고 가정하자.
# <step 1> 시작 노드인 '1'을 큐에 삽입하고 방문 처리를 한다. 
# <step 2> 큐에서 노드 '1'을 꺼내고 방문하지 않은 인접 노드 '2', '3', '8'을 모두 큐에 삽입하고 방문 처리를 한다.
# ....
# ....
# ....
# <step 7> 남아 있는 노드에 방문하지 않은 인접 노드가 없다. 따라서 모든 노드를 차례대로 꺼내면 최종적으로 다음과 같다.
# 결과적을 노드의 탐색 순서(큐에 들어간 순서)는 다음과 같다.
# -->> "1 -->> 2 -->> 3 -->> 8 -->> 7 -->> 4 -->> 5 -->> 6"
# 너비 우선 탐색 알고리즘인 BFS는 큐 자료구조에 기초한다는 점에서 구현이 간단하다.
# 실제로 구현함에 있어서 앞서 언급한 대로 deque 라이브러리를 사용하는 것이 좋으며 탐색을 수행함에 있어 O(N)의 시간이 소요된다.
# -->> "일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라는 점까지만 추가로 기억하자."
# <TIP> -->> "재귀 함수로 DFS를 구현하면 컴퓨터 시스템의 동작 특성상 실제 프로그램의 수행 시간은 느려질 수 있다."
# -->> "따라서 스택 라이브러리를 이용해 시간 복잡도를 완화하는 테크닉이 필요할 때도 있다."
# -->> "다만, 이 내용은 책의 범위를 벗어나므로, 코딩 테스트에서는 보통 DFS보다는 BFS 구현이 조금 더 빠르게 동작한다는 정도만 기억하자."

# 5-9.py BFS 예제
"""
from collections import deque

# BFS 메서드 예제
def bfs(graph, start_v, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start_v])
    # 현재 노드를 방문 처리
    visited[start_v] = True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        cur_v = queue.popleft()
        print(cur_v, end = " ")
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for v in graph[cur_v]:
            if not visited[v]:
                queue.append(v)
                visited[v] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3 ,8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
"""
# DFS와 BFS의 구현에 대해 알아보았는데, 간단히 정리하자면 다음 표와 같다. 더 다양한 방식으로 구현할 수 있지만 책에 실은 예제가 가장 간결한 방식이다.
# ...................................
#           DFS         BFS
# 동작 원리 : 스택          큐
# 구현 방법 : 재귀 함수 이용      큐 자료구조 이용
# ...................................
# 앞서 DFS와 BFS를 설명하는 데 전형적인 그래프 그림을 이용했는 데 1차원 배열이나 2차원 배열 또한 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다.
# 특히나 DFS와 BFS 문제 유형이 그러하다.
# 예를 들어 게임 맵이 3 x 3 형태의 2차원 배열이고,
# 각 데이터를 좌표라고 생각해보자.
# 게임 캐릭터가 (1, 1) 좌표에 있다고 표현할 때처럼 말이다.
# 이때 각 좌표를 상하좌우로만 이동할 수 있다면 
# 어떨까?
# 모든 좌표의 형태를 다음처럼 그래프의 형태로 바꿔서 생각할 수 있다.
# ....
# 코딩 테스트 중 2차원 배열에서의 탐색 문제를 만나면 이렇게 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다. 
# 그러므로 코딩 테스트에서 탐색 문제를 보면 그래프 형태로 표현한 다음 풀이법을 고민하도록 하자.
# 이제 지금까지 배운 내용을 토대로 실전 문제를 풀어보자.
# 참고 > 이러한 방식을 "암시적 그래프(Implicit Graph)"의 표현방식이라고 부릅니다..!!

# <3> 음료수 얼려 먹기

# my solution : BFS를 이용한 풀이 방법입니다..!!
"""
from collections import deque

n, m = list(map(int, input().split()))

graph = [[] for _ in range(n)]

for i in range(0,n):
    graph[i] = list(map(int, input().split()))
# print(graph) <<-- 여기까지 ok..!!

# visited = [[False] * m for _ in range(n)]

def bfs(graph, start_v):
    queue = deque([start_v])
    graph[start_v[0]][start_v[1]] = 2019274
    # visited[start_v[0]][start_v[1]] = True

    while queue:
        cur_v = queue.popleft()

        for d in [(0,1), (0,-1), (-1,0), (1,0)]:
            new_v = (cur_v[0] + d[0], cur_v[1] + d[1])
            if 0 <= new_v[0] <= n-1 and 0 <= new_v[1] <= m-1 and graph[new_v[0]][new_v[1]] == 0:
                queue.append(new_v)
                graph[new_v[0]][new_v[1]] = 20191274
                # visited[new_v[0]][new_v[1]] = True

count = 0

for i in range(0, n):
    for j in range(0, m):
        if graph[i][j] == 0:
            bfs(graph, (i, j))
            count += 1

# print(visited)
print(graph)
print(count)
"""

# 문제 해설
# 이 문제는 DFS로 해결할 수 있다.
# 일단 앞에서 배운 대로 얼음을 얼릴 수 있는 공간이 상, 하, 좌, 우로 연결되어 있다고 표현할 수 있으므로 그래프 형태로 모델링 할 수 있다.
# 예를 들어 다음과 같이 3 x 3 크기의 얼음 틀이 있다고 가정하자.
"""
001
010
101
"""
# 이는 ....
# .... 이러한 묶음을 찾아주는 프로그램을 어떻게 작성할 수 있을까?
# DFS를 이용하면 간단히 해결할 수 있다.
# ...........................................................
# 1. 특정한 지점의 주변 상, 하, 좌, 우를 살펴본 뒤에 주변 지점 중에서 값이 '0'이면서 아직 방문하지 않은 지점이 있다면 해당 지점을 방문한다.
# 2. 방문한 지점에서 다시 상, 하, 좌, 우를 살펴보면서 방문을 다시 진행하면, 연결된 모든 지점을 방문할 수 있다.
# 3. 1 ~ 2번의 과정을 모든 노드에 반복하며 방문하지 않은 지점의 수를 센다.
# ...........................................................
# 소스코드 예시는 다음과 같다.

# 5-10.py 답안 예시
"""
# N, M을 공백으로 구분하여 입력받기
n, m = map(int, input().split())

# 2차원 리스트의 맵 정보 입력받기
graph = []
for i in range(n):
    graph.append(list(map(int, input().split())))

# DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문
def dfs(x, y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        # 해당 노드 방문 처리
        graph[x][y] = 1
        # 상, 하, 좌, 우의 위치도 모두 재귀적으로 호출
        dfs(x, y+1)
        dfs(x, y-1)
        dfs(x-1, y)
        dfs(x+1, y)
        return True
    return False

# 모든 노드(위치)에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        # 현재 위치에서 DFS 수행
        if dfs(i, j) == True:
            result += 1

print(result)
"""

# my solution2 : DFS를 이용한 풀이 방법입니다..!!
"""
n, m = list(map(int, input().split()))

graph = [[] for _ in range(n)]

for i in range(n):
    graph[i] = list(map(int, input().split()))

def dfs(graph, cur_v):
    graph[cur_v[0]][cur_v[1]] = 20191274

    for d in [(0,1), (0,-1), (-1,0), (1,0)]:
        new_v = (cur_v[0] + d[0], cur_v[1] + d[1])
        if 0 <= new_v[0] <= n-1 and 0 <= new_v[1] <= m-1 and graph[new_v[0]][new_v[1]] == 0:
            dfs(graph, new_v)
        else:
            continue

count = 0

for i in range(0, n):
    for j in range(0, m):
        if graph[i][j] == 0:
            dfs(graph, (i,j))
            count += 1

print(graph)
print(count)
"""

# <4> 미로 탈출

# my solution1 : DFS를 이용한 풀이 방법입니다..!!
'''
n, m = map(int, input().split())

graph = [[] for _ in range(n)]

for i in range(n):
    graph[i] = list(map(int, input().split()))

def dfs(graph, cur_v):
    
    for d in [(0,1), (0,-1), (-1,0), (1,0)]:
        new_v = (cur_v[0] + d[0], cur_v[1] + d[1])
        if new_v == (n - 1, m - 1): # <<-- 즉, 목표지점에 도달하게 되면 dfs 함수를 바로 종료시켜버립시다..!!
            graph[new_v[0]][new_v[1]] = graph[cur_v[0]][cur_v[1]] + 1
            return
        if 0 <= new_v[0] <= n-1 and 0 <= new_v[1] <= m-1 and graph[new_v[0]][new_v[1]] == 1:
            graph[new_v[0]][new_v[1]] = graph[cur_v[0]][cur_v[1]] + 1
            dfs(graph, new_v)
            

dfs(graph, (0,0))
print(graph)
print(graph[n-1][m-1])

# 출력 결과 Ex
"""
4 4
1 1 1 1
0 0 0 1
1 1 1 1
1 1 0 1
[[3, 2, 3, 4], [0, 0, 0, 5], [9, 8, 7, 6], [10, 11, 0, 7]]
"""
'''

# my solution2 : BFS를 이용한 풀이 방법입니다..!!
"""
from collections import deque

n, m = list(map(int, input().split()))

graph = [[] for _ in range(n)]

for i in range(n):
    graph[i] = list(map(int, input().split()))

def bfs(graph, start_v):
    queue = deque([start_v])
    
    while queue:
        cur_v = queue.popleft()
        for d in [(0,1), (0,-1), (-1,0), (1,0)]:
            new_v = (cur_v[0] + d[0], cur_v[1] + d[1])
            if 0 <= new_v[0] <= n-1 and 0 <= new_v[1] <= m-1 and graph[new_v[0]][new_v[1]] == 1:
                queue.append(new_v) # <<-- 즉, 큐에 삽입하고,
                graph[new_v[0]][new_v[1]] = graph[cur_v[0]][cur_v[1]] + 1 # <<-- 방문 처리를 해줍니다..!!

bfs(graph, (0,0))
print(graph[n-1][m-1])
"""

# 문제 해설
# 이 문제는 BFS를 이용했을 때 매우 효과적으로 해결할 수 있다. BFS는 시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색하기 때문이다.
# -->> "그러므로 (1, 1) 지점에서부터 BFS를 수행하여 모든 노드의 값을 거리 정보로 넣으면 된다." <<-- "즉, 이 문제에서 거리 정보를 갱신해주는 것이 방문처리를 해주는 것입니다..!!"
# 특정한 노드를 방문하면 그 이전 노드의 거리에 1을 더한 값을 리스트에 넣는다.
# 예를 들어 만약 미로의 크기가 3 x 3이며 오른쪽과 같이 구성되어 있다고 가정해보자.
# 1 1 0
# 0 1 0
# 0 1 1
# ....
# ....
# ....
# 참고로 소스코드 상에서, 첫번째 시작 위치는 다시 방문할 수 있도록 되어 첫 번째 시작 위치에 해당하는 값이 3으로 변경될 여지가 있다.
# 하지만 본 문제에서는 단순히 가장 오른쪽 아래 위치로 이동하는 것을 요구하고 있기 때문에,
# 본 소스코드는 정상적으로 답을 도출하는 간결한 정답 코드이다.

# 5-11.py 답안 예시

from collections import deque

# N, M을 공백으로 구분하여 입력받기
n, m = map(int, input().split())
# 2차원 리스트의 맵 정보 입력받기
graph = [[] for _ in range(n)]
for i in range(n):
    graph[i] = list(map(int, input().split()))

# 이동할 네 방향 정의(상, 하, 좌, 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# BFS 소스코드 구현
def bfs(x, y):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque()
    queue.append((x,y))
    # 큐가 빌 때까지 반복
    while queue:
        x, y = queue.popleft()
        # 현재 위치에서 네 방향으로의 위치 확인
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            # 미로 찾기 공간을 벗어난 경우 무시
            if nx <= -1 or nx >= n or ny <= -1 or ny >= m:
                continue
            # 벽인 경우 무시
            if graph[nx][ny] == 0:
                continue
            # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록
            if graph[nx][ny] == 1:
                if nx == 0 and ny == 0:
                    continue # <<-- 즉, 동빈이가 처음 시작한 지점이라면 continue 문을 통해 빠져나갑시다..!!
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx, ny))
    # 가장 오른쪽 아래까지의 최단 거리 반환
    return graph[n - 1][m - 1]

# BFS를 수행한 결과 출력
print(bfs(0,0))
