# <Q27> 정렬된 배열에서 특정 수의 개수 찾기

# my solution
"""
from bisect import bisect_left, bisect_right

def count_by_range(array, left_value, right_value):
    left_index = bisect_left(array, left_value)
    right_index = bisect_right(array, right_value) - 1
    return right_index - left_index + 1

n, x = map(int, input().split())
array = list(map(int, input().split()))

# 단, 문제의 조건中에서 값이 x인 원소가 하나도 없다면 -1을 출력하라했으므로 위에서 정의한 함수의 반환값이 0이라면 "print(-1)"처리를 해주도록 합시다..!!
if count_by_range(array, x, x) == 0:
    print(-1)
else:
    print(count_by_range(array, x, x))
"""

# <Q28> 고정점 찾기

# my solution : 배열 내의 인덱스 값과 해당 인덱스에 따른 배열의 결괏값 사이의 규칙성을 찾으면 어렵지 않게 풀 수 있는 문제인 것 같습니다..!!
"""
def binary_search(array, start, end): # <<-- 여기서 target 매개변수가 필요없는 이유는 어차피 target이 인덱스가 되기 때문에 따로 매개변수를 설정할 필요가 없기 때문이다..!!
    while start <= end:
        mid = (start + end) // 2
        if array[mid] == mid:
            return mid
        elif array[mid] > mid:
            end = mid - 1
        elif array[mid] < mid:
            start = mid + 1
    return -1

n = int(input())
array = list(map(int, input().split()))

print(binary_search(array, 0, n - 1))
"""

# <Q29> 공유기 설치

# my solution (X)

# <A29> 공유기 설치
# 이 문제는 '가장 인접한 두 공유기 사이의 거리'의 최댓값을 탐색해야 하는 문제로 이해할 수 있다.
# -->> "이때 각 집의 좌표가 최대 10억(탐색 범위가 10억)이므로," -->> "이진 탐색을 이용하면 문제를 해결할 수 있다."
# -->> "따라서 이진 탐색으로 '가장 인접한 두 공유기 사이의 거리'를 조절해가며, 매 순간 실제로 공유기를 설치하여 C보다 많은 개수로 공유기를 설치할 수 있는지
# 체크하여 문제를 해결할 수 있다."
# 다만, '가장 인접한 두 공유기 사이의 거리'의 최댓값을 찾아야 하므로, C보다 많은 개수로 공유기를 설치할 수 있다면 '가장 인접한 두 공유기 사이의 거리'의 값을 증가시켜서, -->> 더 큰 값에 대해서도 성립하는지 체크하기 위해 다시 탐색을 수행한다.
# 이 문제는 7장에서 다룬 "떡볶이 떡 만들기" 문제와 유사하게 이진 탐색을 이용해 해결할 수 있는 파라메트릭 서치 유형의 문제로 이해할 수 있다.
# 예를 들어 5개의 집이 있고, 각 좌표를 담은 수열이 [1, 2, 4, 8, 9]와 같다고 해보자.
# 또한 설치할 공유기의 최소 개수 C = 3이라고 하자. 이때 가장 인접한 두 공유기 사이의 거리(gap)는 1부터 8까지의 수가 될 수 있다.
# * 최대 gap : 8 # -->> array[-1] - array[0] (단, 오름차순 정렬 기준입니다..!!)
# * 최소 gap : 1
# <step 1> 범위가 1부터 8까지이므로, gap의 값을 중간에 해당하는 4로 설정한다. 다만, 이 경우, 공유기를 2개 밖에 설치할 수 없다. 따라서 C = 3보다 작기 때문에, gap을 더 줄일 필요가 있다.
# 따라서 범위가 [1, 8]이었으므로, 범위를 [1, 3]으로 수정한다. (공유기를 앞에서 부터 차례대로 설치할 때, 공유기가 설치되는 위치는 하늘색으로 색칠하였다.)
# * 최대 gap : 8
# * 최소 gap : 1    gap = 4 ....
# <step 2> 범위가 1부터 3이므로, gap의 값을 중간에 해당하는 2로 설정한다. 이 경우, 공유기를 3개 설치하게 된다. 따라서 C = 3 이상의 값이기 때문에, -->> 현재의 gap을 저장한 뒤에 gap의 값을 증가시켜서
# -->> gap의 값이 더 커졌을 때도 가능한지 확인할 필요가 있다. -->> 따라서 범위가 [1, 3]인 상태에서 범위를 [3, 3]으로 설정한다.
# * 최대 gap : 3
# * 최소 gap : 1    gap = 2 ....
# <step 3> 범위가 3부터 3까지이므로, gap의 값을 중간에 해당하는 3으로 설정한다. 이 경우, 공유기를 3개 설치하게 된다.
# 따라서 C = 3 이상의 값이기 때문에, -->> 현재의 gap을 저장한 뒤에 gap의 값을 증가시켜서 gap이 더 커졌을 때도 가능한지 확인할 필요가 있다.
# -->> 하지만 현재의 범위가 [3, 3]이므로, -->> 더 이상 범위를 변경할 수 없다.
# -->> "따라서 gap = 3이 최적의 경우이다."
# * 최대 gap : 3
# * 최소 gap : 3    gap = 3 ....
# -->> 이러한 과정을 소스코드로 담으면 다음과 같다.

# A29 답안 예시
"""
# 집의 개수(N)와 공유기의 개수(C)를 입력받기
n, c = list(map(int, input().split()))

# 전체 집의 좌표 정보를 입력받기
array = []
for _ in range(0, n):
    array.append(int(input()))
array.sort() # 이진 탐색 수행을 위해 정렬 수행

start = 1 # 가능한 최소 거리(min gap)
end = array[-1] - array[0] # 가능한 최대 거리(max gap)
result = 0

while start <= end:
    mid = (start + end) // 2 # mid는 가장 인접한 두 공유기 사이의 거리(gap)을 의미
    value = array[0]
    count = 1
    # 현재의 mid 값을 이용해 공유기를 설치
    for i in range(1, n): # 앞에서부터 차근차근 설치
        if array[i] >= value + mid:
            value = array[i]
            count += 1
    if count >= c: # C개 이상의 공유기를 설치할 수 있는 경우, 거리를 증가
        start = mid + 1
        result = mid # 최적의 결과를 저장 # <<-- 다음 번에 안될 상황을 대비해 그때그때마다 저장해주는 것입니다..!!
    else: # C개 이상의 공유기를 설치할 수 없는 경우, 거리를 감소
        end = mid - 1

print(result)
"""

# <Q30> 가사 검색

# my solution (X)

# <A30> 가사 검색
# 이 문제는 이진 탐색을 이용해서 간결하게 해결할 수 있다. -->> "먼저 각 단어를 길이에 따라서 나눈다."
# -->> "이후에 모든 리스트를 정렬한 뒤에," -->> "각 쿼리에 대해서 이진 탐색을 수행하여 문제를 해결할 수 있다."
# 예를 들어 문제의 예시와 같이 전체 단어가 ["frodo", "front", "frost", "frozen", "frame", "kakao"]로 구성되어 있다고 해보자.
# 이때 각각의 리스트를 길이에 따라서 나누면 다음과 같다.
# * 길이가 5인 단어 리스트 : ["frodo", "front", "frost", "frame", "kakao"]
# * 길이가 6인 단어 리스트 : ["frozen"]
# -->> "이후에 각 리스트를 정렬하면 다음과 같다(단, 여기서 정렬 기준은 아스키 코드 기준입니다..!! -->> 즉 사전 순(알파벳 순) 정렬..!!)"
# * 길이가 5인 단어 리스트 : ["frame", "frodo", "front", "frost", "kakao"]
# * 길이가 6인 단어 리스트 : ["frozen"]
# 이제 "fro??"라는 쿼리가 들어왔다고 가정하면 "fro??"는 길이가 5이므로 길이가 5인 단어 리스트에서 "fro"로 시작하는 모든 단어를 찾으면 됩니다..!!
# 이때 구체적을 이진 탐색(Binary Search)을 이용해서 "fro"로 시작되는 마지막 단어의 위치를 찾고, "fro"로 시작하는 첫 단어의 위치를 찾아서 그 위치의 차이를 계산하면 될 것이다.
# 이처럼 이진 탐색을 수행하는 경우 특정한 단어가 등장한 횟수를 계산할 수 있다.
# -->> " 혹은 "fro??"라는 쿼리가 들어왔을 때, 부록에서 다루었던 count_by_range() 함수를 이용하여 "froaa"보다 크거나 같으면서 "frozz"보다 작거나 같은 단어의 개수를 세도록 구현하면 매우 간단하다. "
# 이는 앞서 풀어본 'Q27 정렬된 배열에서 특정 수의 개수 구하기'와 유사한 접근 방법이다.
# -->> "다만, 문제에서는 와일드 카드 "?"가 접두사에도 등장할 수 있다고 하였다."
# 만약 "????o"라는 쿼리가 들어왔다고 가정해보자. 이는 기존의 리스트인 ["frame", "frodo", "front", "frost", "kakao"]를 이용해서 처리할 수 없을 것이다.
# -->> "따라서 접두사에 와일드카드가 등장하는 것을 처리하기 위해서 기존 단어를 뒤집은 단어를 담고 있는 리스트 또한 별도로 선언해야 한다."
# 현재 예시에서는 길이가 5인 뒤집힌 단어 리스트는 ["emarf", "oakak", "odorf", "tnorf", "tsorf"]이다. 결과적으로 접두사에 와일드카드가 등장하는 경우,
# 뒤집힌 단어 리스트를 대상으로 이진 탐색을 수행하면 된다.
# 이러한 아이디어를 소스코드로 옮기면 다음과 같다.

# A30.py 답안 예시
"""
# 이 코드는 다음 프로그래머스 사이트에서 테스트해야 정상 동작한다.
# ....

from bisect import bisect_left, bisect_right

# 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(array, left_value, right_value):
    left_index = bisect_left(array, left_value)
    right_index = bisect_right(array, right_value) - 1
    return right_index - left_index + 1

# 모든 단어를 길이마다 나누어서 저장하기 위한 리스트
array = [[] for _ in range(10001)]
# 모든 단어를 길이마다 나누어서 뒤집어 저장하기 위한 리스트
reversed_array = [[] for _ in range(10001)]

def solution(words, queries):
    answer = []
    for word in words: # 모든 단어를 접미사 와일드카드 배열, 접두사 와일드카드 배열에 각각 삽입
        array[len(word)].append(word) # 단어를 삽입
        reversed_array[len(word)].append(word[-1::-1]) # 단어를 뒤집어서 삽입
    
    for i in range(10001): # 이진 탐색을 수행하기 위해 각 단어 리스트 정렬 수행
        array[i].sort()
        reversed_array[i].sort()
    
    for q in queries: # 쿼리를 하나씩 확인하며 처리
        if q[0] != "?": # 접미사에 와일드카드가 붙은 경우
            res = count_by_range(array[len(q)], q.replace("?","a"), q.replace("?","z"))
        else: # 접두사에 와일드카드가 붙은 경우
            res = count_by_range(reversed_array[len(q)], q[-1::-1].replace("?","a"), q[-1::-1].replace("?","z"))
        # 검색된 단어의 개수를 저장
        answer.append(res)
    return answer
"""

