# 문제 설명 : ....
# ....
# ....
# * 효율성 테스트에 부분 점수가 있는 문제입니다.

# my solution1 : 정확성 (O), 효율성 (X)
"""
def solution(food_times, k):
    answer = 0
    idx = 0
    for time in range(0, k):
        while food_times[idx % len(food_times)] == 0:
            if food_times == [0] * len(food_times):
                return -1
            idx += 1
        food_times[idx % len(food_times)] -= 1
        idx += 1
    
    # print(idx)
    while food_times[idx % len(food_times)] == 0:
            if food_times == [0] * len(food_times):
                return -1
            idx += 1
    
    return idx % len(food_times) + 1
"""

# <A06> 무지의 먹방 라이브
# 이 문제는 시간이 적게 걸리는 음식부터 확인하는 탐욕적(Greedy) 접근 방식으로 해결할 수 있다.
# 모든 음식을 시간을 기준으로 정렬한 뒤에, 시간이 적게 걸리는 음식부터 제거해 나가는 방식을 이용하면 된다.
# 이를 위해 우선순위 큐를 이용하여 구현할 수 있는데, 
# 문제를 풀기 위해 고려해야 하는 부분이 많아서 까다로울 수 있다.
# 간단한 예시로 다음과 같이 3개의 음식이 있으며, K를 15초라고 해보자.
# * 1번 음식 : 8초 소요
# * 2번 음식 : 6초 소요
# * 3번 음식 : 4초 소요
# <step 0> 초기 단계에서는 모든 음식을 우선순위 큐(최소 힙)에 삽입한다. 또한 마지막에는 K초 후에 먹어야 할 음식의 번호를 출력해야 하므로 우선순위 큐에 삽입할 때 (음식 시간, 음식 번호)의 튜플 형태로 삽입한다.
# 그 형태는 오른쪽과 같다. -->> ....
# * 전체 남은 시간(K) : 15초
# * 남은 음식 : 3초
# <step 1> 첫 단계에서는 가장 적게 걸리는 음식인 3번 음식을 뺀다. 다만, 음식이 3개 남아 있으므로 3(남은 음식의 개수) X 4(3번 음식을 먹는 시간) = 12를 빼야 한다.
# 결과적으로 전체 남은 시간이 15초에서 3초로 줄어들게 된다.
# * 전체 남은 시간(K) : 3초
# * 남은 음식 : 2개
# -->> ....
# * 먹은 음식들 : (4, 3)
# <step 2> 전체 남은 시간이 3초이고, 이번 단계에서는 2번 음식을 빼야 한다. 전체 음식이 2개 남아 있으므로 이번 단계에서 뺄 시간은 2(남은 음식의 개수) X 2(2번 음식을 다 먹는 시간) = 4초가 된다.
# 하지만 현재 전체 남은 시간이 3초인데, 이는 4보다 작으므로 빼지 않도록 한다.
# 따라서 "다음으로 먹어야 할"음식의 번호를 찾아 출력하면 된다.
# 다음 그림처럼 매초 먹어야할 음식들을 일렬로 나열해보자.
# 전체 남은 시간이 3초이므로, 4번째 음식의 번호를 출력하면 정답이다.
# * 전체 남은 시간(K) : 3초
# * 남은 음식 : 2개
# -->> (8, 1), (6, 2), (8, 1), (6, 2)
# 따라서 2번 음식을 출력한다.
# 소스코드는 다음과 같은데, -->> "필자는 '우선순위 큐'를 '구현'하기 위해 'heapq'를 '이용'했다."
# 우선순위 큐에 대한 내용은 다익스트라 알고리즘 파트에서 다루었으니, 여기에서 추가로 언급하지는 않겠다.

# A06.py 답안 예시

# 이 코드는 다음 프로그래머스 사이트에서 테스트해야 정상 동작한다.
# ....

import heapq

def solution(food_times, k):
    # 전체 음식을 먹는 시간보다 k가 크거나 같다면 -1
    # -->> 어차피 모든 음식의 잔여량이 0이 될 것이기 때문입니다..!!
    if sum(food_times) <= k:
        return -1
    
    # 시간이 작은 음식부터 빼야 하므로 우선순위 큐를 이용
    q = []
    for i in range(0, len(food_times)):
        # (음식 시간, 음식 번호) 형태로 우선순위 큐에 삽입
        heapq.heappush(q, (food_times[i], i + 1))
    
    current_time = 0 # 현재 시간
    cycle = 0 # 현재까지 회전판을 몇번 돌았는지 카운팅해주는 변수입니다..!!

    length = len(food_times) # 남은 음식의 개수

    # ....
    while current_time + ((q[0][0] - cycle) * length) <= k: # 참고 > current_time : 현재 시간 , K : 주어진 총 시간
        # -->> 즉, 다 먹는데 걸리는 시간이 적은 음식부터 차근차근 체크하되..!!
        # -->> 그 음식을 다 먹고도 총 시간을 넘지 않으면 우선순위 큐에서 빼주는 방식으로 진행할 것입니다..!!
        now = heapq.heappop(q)[0]
        current_time += (now - cycle) * length
        length -= 1 # 다 먹은 음식 제외
        cycle = now # 현재까지 회전판을 돈 횟수 갱신해줌..!!
    
    # 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    result = sorted(q, key = lambda x : x[1]) # 음식의 번호 기준으로 정렬
    return result[(k - current_time) % length][1]
