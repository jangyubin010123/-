# <Q04> 만들 수 없는 금액

# my solution (X) -->> "다음에 다시 한 번 풀어볼 것..!!"

# <A04> 만들 수 없는 금액
# 이 문제는 정렬을 이용한 그리디 알고리즘으로 해결할 수 있는 문제이다.
# 문제 해결을 위한 정확한 아이디어를 떠올리기 위해서는 충분히 고민을 해야 하는 문제이므로, 그리디 알고리즘에 익숙하지 않은 독자라면 문제 해결이 쉽지 않을 수 있다.
# 문제 해결 아이디어는 다음과 같다.
# 일단 동전에 대한 정보가 주어졌을 때, 화폐 단위를 기준으로 오름차순 정렬한다.
# 이후에 1부터 차례대로 특정한 금액을 만들 수 있는지 확인하면 된다. 1부터 target - 1까지의 모든 금액을 만들 수 있다고 가정해보자.
# 우리는 화폐 단위가 작은 순서대로 동전을 확인하며, 현재 확인하는 동전을 이용해 target 금액 또한 만들 수 있는지 확인하면 된다.
# 만약 target 금액을 만들 수 있다면, target 값을 업데이트(증가시키는) 방식을 이용한다.
# -->> 기본적으로 그리디 알고리즘은, 현재 상태에서 가장 좋아 보이는 것만을 선택하는 알고리즘이라고 하였다.
# -->> 구체적으로 현재 상태를 "1부터 target - 1까지의 모든 금액을 만들 수 있는 상태"라고 보자.
# -->> 이때 매번 target인 금액도 만들 수 있는지(-->> "현재 확인하는 동전의 단위가 target 이하인지") 체크하는 것이다.
# 만약 해당 금액을 만들 수 있다면, target의 값을 없데이트(현재 상태를 업데이트)하면 된다.
# 예를 들어 3개의 동전이 있고, 각 화폐의 단위가 1, 2, 3이라고 하자. "원"은 생략하겠다.
# 그러면 1부터 6까지의 모든 금액을 만들 수 있다.
# * 1원 : 1
# * 2원 : 2
# * 3원 : 3
# * 4원 : 1 + 3
# * 5원 : 2 + 3
# * 6원 : 1 + 2 + 3
# 그다음 우리는 금액 7도 만들 수 있는지 확인하면 된다. 이때 화폐 단위가 5인 동전 하나가 새롭게 주어졌다고 가정하자.
# 이제 화폐 단위가 5인 동전이 주어졌기 때문에, 1부터 11까지의 모든 금액을 만들 수 있다.
# 예를 들면 다음과 같이 1부터 11까지의 모든 금액을 만들 수 있다.
# (당연히 금액 7도 만들 수 있다는 것이 자동으로 성립한다.)
# ....
# ....
# ....
# 이후에 우리는 금액 12도 만들 수 있는지 확인만 하면 되는 방식이다.
# 이때 화폐 단위가 13인 동전 하나가 새롭게 주어졌다고 가정하자.
# 이때 금액 12를 만드는 방법은 존재하지 않는다.
# 그래서 이 경우에는 정답이 12가 된다.
# 이제 또 다른 예시를 확인해보자.
# 이번에는 문제를 해결하는 과정을 단계별로 보이겠다.
# 만약에 동전을 4개 가지고 있고, 화폐 단위가 각각 1, 2, 3, 8이라고 해보자.
# <step 0> 처음에는 금액 1을 만들 수 있는지 확인하기 위해, target = 1로 설정한다.
# <step 1> target = 1을 만족할 수 있는지 확인한다. 우리에게는 화폐 단위가 1인 동전이 있다. 우리는 이 동전을 이용해서 금액 1을 만들 수 있다. 이어서 target = 1 + 1 = 2로 업데이트를 한다.(1까지의 모든 금액을 만들 수 있다는 말과 같다.)
# <step 2> target = 2를 만족할 수 있는지 확인한다. 우리에게는 화폐 단위가 2인 동전이 있다. 따라서 target = 2 + 2 = 4가 된다. (3까지의 모든 금액을 만들 수 있다는 말과 같다.)
# <step 3> target = 4를 만족할 수 있는지 확인한다. 우리에게는 화폐 단위가 3인 동전이 있다. 따라서 target = 4 + 3 = 7이 된다. (6까지의 모든 금액을 만들 수 있다는 말과 같다.)
# <step 4> target = 7을 만족할 수 있는지 확인한다. 우리에게는 이보다 큰, 화폐 단위가 8인 동전이 있다. 따라서 금액 7을 만드는 방법은 없다. 따라서 정답은 7이 된다.
# 이러한 원리를 이용하면, 단순히 동전을 화폐 단위 기준으로 정렬한 뒤에, 화폐 단위가 작은 동전부터 하나씩 확인하면서 target 변수를 업데이트하는 방법으로 최적의 해를 계산할 수 있다.
# 이 문제는 그리디 알고리즘 유형의 문제를 여러 번 풀어보았다면 풀이 방법을 떠올릴 수 있지만,
# 그리디 알고리즘이 익숙하지 않다면 쉽게 이해되지 않을 수 있는 문제이다.
# 따라서 이 문제가 어렵다면 그리디 알고리즘 유형의 문제를 더욱 많이 접해보자.
# 참고로 이 문제는 앞서 이론 파트에서 다루었던 "거스름돈" 문제와는 다른 문제이다.
# 거스름돈 문제는 각 화폐 단위마다 무한 개의 동전이 존재한다고 가정했는데, 여기서는 동전의 수가 한정적이라는 점이 다르다.

# A04.py 답안 예시

n = int(input())
data = list(map(int, input().split()))
data.sort()

target = 1
# 참고 > "target = number"가 의미하는 바는 현재까지 1부터 number - 1까지의 금액을 만들 수 있다는 뜻으로 그 다음으로는 number원이 만들어질 수 있는지 체킹하겠다는 뜻입니다..!!"
for x in data:
    # 만들 수 없는 금액을 찾았을 때 반복 종료
    if target < x :
        break
    # 즉, 현재까지 만들 수 있는 금액이 "1 ~ target -1"까지인데, "target >= x"를 만족하였으므로 이로 인해 만들어질 수 있는 금액의 범위가 "1 ~ target + x - 1"로 바꼈기 때문입니다..!!
    # -->> 따라서, 다음으로 체킹할 target은 자동으로 "target + x"가 됩니다..!!
    target += x

# 만들 수 없는 금액 출력
print(target)
