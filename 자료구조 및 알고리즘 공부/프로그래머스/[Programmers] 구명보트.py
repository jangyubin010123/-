# my solution

# my thoughts : 구명보트를 최대한 적게 사용하기 위해서는 최대한 무게 제한에 맞추면서 사람들을 2명씩 태울 수 있으면 2명씩 태워야 합니다..!!
# -->> 그렇다면 무게 제한에 최대한 맞추면서 태울려면 어떻게 해야하는가..??
# 내가 처음에 생각한 방법 (방법1)) 몸무게를 기준으로 오름차순 정렬을 시행하여 몸무게가 적은 사람부터 2명씩 구명보트를 태우는 방법 (X)
# 다시 생각해본 방법 (방법2)) 위 방법처럼 정렬을 하되 무인도에 남아있는 사람들 중 몸무게가 가장 큰 사람과 몸무게가 가장 작은 사람 2명을 구명보트에 태우는 방법 (O)
# -->> Q. 방법1이 안되는 이유는..??
# -->> A. 예시를 하나 들어보겠다..!!
# (Example) limit = 150, people = [50, 60, 70, 80, 90, 100]
# 즉, 만약 방법1처럼 사람들을 태운다면 (50+60) , (70+80) , (90) , (100) 이 되어서 총 4개의 구명보트를 이용해야 하지만 이 예제에서 정답은 방법2를 사용해서 구한 3개이다..!!
# -->> 즉, 방법1은 무게 제한에 최대한 맞추지 못한 방법이라고 결론을 지을 수 있다..!!
# -->> 따라서, 우리는 방법2를 통해서 이 문제에 접근해야 합니다..!!

from collections import deque

def solution(people, limit):
    answer = 0
    people.sort() # <<-- 일단, people 리스트를 오름차순 정렬해줍시다..!!
    # 또한 방법2를 쉽게 구현하기 위해서 deque 자료구조를 활용합시다..!!
    people = deque(people)
    # print(people) # 출력결과 Ex : deque([70, 70, 70, 70, 70, 70])
    
    while people:
        if len(people) == 1: # <<-- 마지막에 한 사람만 남는 상황이라면 구명보트를 하나 더 추가해주고 while문에서 나가면 됩니다..!!
            people.pop()
            answer += 1
            break
        # 즉 위의 if문을 수행하지 않고 지났다는 것은 현재 무인도에 갇힌 사람이 아직 2명 이상이라는 뜻입니다..!!
        
        # 만약 몸무게가 큰 사람과 작은 사람의 합이 무게 제한보다 초과한다면 몸무게가 큰 사람은 혼자 타야하는 상황이므로 몸무게가 큰 사람을 무인도에서 탈출시키고 "answer += 1" 처리를 해주면 됩니다..!!
        if people[0] + people[-1] > limit:
            people.pop()
            answer += 1
        # 만약 몸무게가 큰 사람과 적은 사람의 합이 무게 제한보다 같거나 작은 상황이라면 이때는 구명보트에 2명 태울 수 있다는 뜻이므로 해당 두 사람을 무인도에서 탈출시키고 "answer += 1" 처리를 해주면 됩니다..!!
        else:
            people.popleft()
            people.pop()
            answer += 1
            
    return answer
