# CHAPTER > 08 : 다이나믹 프로그래밍
# -->> "한번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘"

# <1> 다이나믹 프로그래밍

# -->> "중복되는 연산을 줄이자"
# 현실 세계에는 다양한 문제가 있다. 그런데 이 중에서 컴퓨터를 활용해도 해결하기 어려운 문제는 무엇일까? 
# 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요한 문제 등이 컴퓨터로도 해결하기 어려운 문제이다.
# 컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다.
# 그래서 우리는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.*
# * ....
# -->> "다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다."
# -->> "대표적인 방법이 바로 이번 장에서 다루는 '다이나믹 프로그래밍(Dynamic Programming)기법'으로 '동적 계획법'이라고 '표현'하기도 한다."
# -->> 먼저 다이나믹 프로그래밍의 기본적인 아이디어를 소개한 뒤에, -->> "다이나믹 프로그래밍의 2가지 방식('탑다운'과 '보텀업')을 설명할 것이다."
# -->> 특히 다이나믹 프로그래밍을 위해 자주 사용되는 '메모이제이션 기법'까지 '소개'하겠다.
# 여기서 잠깐 >
# '다이나믹 프로그래밍'(== '동적 계획법')과 동적 할당의 다이나믹은 같은 의미일까?
# -->> 지금까지 다룬 알고리즘은 이름으로 동작 과정을 유추할 수 있었지만 다이나믹 프로그래밍은 감이 오지 않을 것이다. -->> 프로그래밍에서 다이나믹은 '프로그램이 실행되는 도중에'라는 의미이다.
# -->> 예를 들어 자료구조에서 동적 할당(Dynamic Allocation)은 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법이다.
# -->> "하지만 다이나믹 프로그래밍에서의 '다이나믹'은 이런 의미가 아니라는 것 정도만 기억하자..!!"
# -->> 다이나믹 프로그래밍에 대해 알아보기 전에 기존의 알고리즘으로 해결하기 어려운 문제 중에서 '다이나믹 프로그래밍'으로 해결할 수 있는 문제를 살펴보자.
# 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다.
# 피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.
# 피보나치 수열은 다음과 같은 형태로 끝없이 이어진다.
# -->> 1 1 2 3 5 8 13 21 34 55 89 ....
# 수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현한다.
# '점화식'이란 인접한 항들 사이의 관계식을 의미하는데, 예를 들어 ....
# 우리는 점화식을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.
# ....
# 이러한 점화식은 인접 3항간 점화식이라고 부르는데 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.
# ....
# -->> 프로그래밍에서는 이러한 수열을 '배열'이나 '리스트'로 표현할 수 있다.
# 수열 자체가 여러 개의 수가 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.
# 파이썬에선느 리스트 자료형이 이를 처리하고, ....
# -->> 리스트나 배열 모두 '연속된 많은 데이터'를 처리한다는 점은 동일하다.
# ....
# 그런데 f(2)와 f(1)은 항상 1이기 때문에 f(1)이나 f(2)를 만났을 때는 호출을 정지한다.
# -->> 수학적 점화식을 프로그래밍으로 표현할려면 재귀 함수를 사용하면 간단하다.
# 예시를 소스코드로 바꾸면 다음과 같다.

# 8-1.py 피보나치 함수 소스코드
"""
# 피보나치 함수(Fibonacci Function)를 재귀 함수로 구현
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))
"""
# 참고 > "파이썬의 경우" -->> "기본 자료형인 리스트 자료형이 연결 리스트의 기능을 포함하고 있는 점"이 -->> "다른 프로그래밍 언어에서의 배열과 차이점"이다.
# 그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있다. -->> "바로 f(n)함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다."
# 이 소스코드의 시간 복잡도는, 엄밀히 말하면 ....
# -->> "하지만 일반적으로는 빅오 표기법을 이용하여 O(2**N)의 지수 시간이 소요된다고 표현한다."
# 예를 들어 N = 30이면, 약 10억 가량의 연산을 수행해야 한다. f(6)일 때의 호출 과정을 그림으로 그려 확인해보자.
# ....
# -->> "그림을 보면 동일한 함수가 반복적으로 호출되는 것을 알 수 있다."
# -->> "이미 한번 계산했지만, 계속 호출할 때마다 계산하는 것이다."
# -->> "즉, f(n)에서 n이 커지면 커질수록 반복해서 호출하는 수가 많아진다."
# ....
# -->> "아마 현대의 2진수 처리 방식을 가진 컴퓨터 구조에 기반한 시스템에서 연산을 수행했을 때 우리의 수명이 다할 때까지 연산을 진행해도 답을 도출할 수 없을 것이다..!!"
# 이처럼 피보나치 수열의 점화식을 재귀 함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다.
# -->> "이러한 문제는 '다이나믹 프로그래밍'을 효율적으로 해결할 수 있다."
# 다만 매번 다이나믹 프로그래밍을 사용할 수는 없으며, 다음 조건을 만족할 때 사용할 수 있다.
# ...............................................................
# -->> "1. 큰 문제를 작은 문제로 나눌 수 있다."
# -->> "2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다."
# ...............................................................
# 피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.
# -->> 이 문제를 '메모이제이션(Memoization)기법'을 사용해서 해결해보자.
# -->> '메모이제이션'은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로,
# -->> "한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다."
# -->> "메모이제이션"은 '값을 저장하는 방법'이므로 "캐싱(Cashing)"이라고도 한다.
# -->> "그렇다면 실제로 메모이제이션은 어떻게 구현될 수 있을까?" -->> 단순하다. "한 번 구한 정보를 리스트에 저장하는 것이다."
# 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오면 된다.
# 이를 소스코드로 나타내면 다음과 같다.

# 8-2.py 피보나치 수열 소스코드(재귀적)
""""
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적이 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
"""
# 파이썬 프로그래밍을 실행해보면 99번째 피보나치 수를 구하도록 했음에도 불구하고 금방 정답을 도출하는 것을 알 수 있다.
# -->> 정리하자면 "다이나믹 프로그래밍"이란 -->> "큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다."
# 사실 큰 문제를 작은 문제로 작게 나누는 방법은 퀵 정렬에서도 소개된 적이 있다. 퀵 정렬은 정렬을 수행할 때 정렬할 리스트를 분할하며 전체적으로 정렬이 될 수 있도록 한다.
# 이는 분할 정복(Divide and Conquer)알고리즘으로 분류된다.
# -->> "다이나믹 프로그래밍과 분할 정복의 차이점은 -->> "다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.""
# 퀵 정렬을 예로 들면, 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡게 되면, 그 기준 원소의 위치는 더 이상 바뀌지 않고 그 피벗값을 다시 처리하는 부분 문제는 존재하지 않는다.
# -->> "반면에 다이나믹 프로그래밍은 한 번 해결했던 문제를 다시금 해결한다는 점이 특징이다."
# -->> "그렇기 때문에 이미 해결된 부분 문제에 대한 답을 저장해 놓고,"
# -->> 이 문제는 이미 해결이 됬던 것이니까 다시 해결할 필요가 없다고 반환하는 것이다.
# -->> 예를 들어 '재귀 함수를 이용하는 방법'('메모이제이션')에서는 한 번 푼 문제는 그 결과를 저장해 놓았다가 나중에 동일한 문제를 풀어야 할 때 이미 저장한 값을 반환한다.
# f(6) 해법을 다시 메모이제이션 기법을 이용하여 그려보면 6번째 피보나치 수를 호출할 때는 다음 그림처럼 색칠된 노드만 방문하게 된다.
# ....
# ....
# 물론 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출할 때는 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다.
# -->> 따라서 '재귀 함수' 대신에 -->> '반복문을 사용'하여 오버헤드를 줄일 수 있다.
# -->> 일반적으로 반복문을 이용한 다이나믹 프로그래밍이 더 성능이 좋기 때문이다.
# 그렇다면 다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 어떻게 될까?
# -->> "바로 O(N)이다." -->> 왜냐하면 f(1)을 구한 다음 그 값이 f(2)를 푸는 데 사용되고, f(2)의 값이 f(3)을 푸는데 사용되는 방식으로 이어지기 때문이다.
# 한 번 구한 결과는 다시 구해지지 않는다.
# 따라서 실제로 호출되는 함수에 대해서만 확인해보면 다음과 같이 방문한다.
# ''''''''''''''''''''''
# f(6), f(5), f(4), f(3)
# ''''''''''''''''''''''
# 이로써 시간 복잡도가 O(N)이라는 것을 쉽게 이해할 수 잇다.
# 소스코드는 다음과 같다.

# 8-3.py 호출되는 함수 확인
"""
d = [0] * 100

def pibo(x):
    print('f('+str(x)+')', end = " ")
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = pibo(x-1) + pibo(x-2)
    return d[x]

pibo(6)
"""
# -->> 이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 "탑다운(Top-Down)방식"이라고 말한다.
# -->> 반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 "보텀업(Bottom-Up)방식"이라고 말한다.
# 피보나치 수열 문제를 아래에서 위로 올라가는 보텀업 방식으로 풀면 다음과 같다.
# 동일한 원리를 적용하되 단순히 반복문을 이용하여 문제를 해결하는 것으로 이해하면 된다.

# 8-4.py 피보나치 수열 소스코드(반복적)
"""
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수(Fibonacci Function) 반복문으로 구현 (보텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i-1] + d[i-2] # -->> "즉, 작은 문제부터 차근차근 답을 도출하는 식입니다..!!"

print(d[n])
"""
# 탑다운(메모이제이션) 방식은 '하향식'이라고도 하며, 보텀업 방식은 '상향식'이라고도 한다.
# 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
# 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며,
# 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
# 다이나믹 프로그래밍과 메모이제이션의 개념을 혼용해서 사용하는 경우도 있는데, -->> 엄밀히 말하면 '메모이제이션'은 '이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미'하므로,
# 다이나믹 프로그래밍과는 별도의 개념이다. 한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
# ...., -->> 메모이제이션은 때에 따라서 다른 자료형, 예를 들어 사전(dict) 자료형을 이용할 수도 있다.
# 사전 자료형은 수열처럼 연속적이지 않은 경우에 유용한데,
# ....
# 이럴 때에는 사전 자료형을 사용하는게 더 효과적이다.
# ....
# 하지만 코딩 테스트에서의 다이나믹 프로그래밍 문제는 대체로 간단한 형태로 출제되므로, 이 책에서 다루는 문제 정도만 바르게 습득해도 코딩 테스트에서 다이나믹 프로그래밍 문제를 풀기에는 큰 어려움이 없을 것이다.
# 문제를 푸는 첫 번째 단계는 (당연하게 들리겠지만) 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이다.
# 특정한 문제를 완전 탐색 알고리즘으로 접근 했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자.
# 일단 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모이제이션을 적용할 수 있으면 코드를 개선하는 방법도 좋은 아이디어이다.
# ....
# -->> "또한 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다."
# 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.
# 실제로 앞에서 제시한 재귀적인 피보나치 수열의 소스코드에서 오천 번째 이상의 큰 피보나치 수를 구하도록 하면 'recursion depth'와 관련된 오류가 발생할 수 있다.
# ....
# -->> "지금까지 배운 내용을 토대로 실전 문제를 풀어보자..!!"

# <2> 1로 만들기
# 정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
# a. X가 5로 나누어떨어지면, 5로 나눈다.
# b. X가 3으로 나누어떨어지면, 3으로 나눈다.
# c. X가 2로 나누어떨어지면, 2로 나눈다.
# d. X에서 1을 뺀다.
# 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
# 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
# 1. 26 - 1 = 25 (d)
# 2. 25 / 5 = 5 (a)
# 3. 5 / 5 = 1 (a)
# 입력 조건 : * 첫째 줄에 정수 X가 주어진다. (1 <= X <= 30,000)
# 출력 조건 : * 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
# 입력 예시 : 26
# 출력 예시 : 3

# my solution``
"""
x = int(input())
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 -->> # 참고 > DP : "Dynamic Programming"
d = [0] * 30001 

for i in range(1, x + 1):
    if i == 1:
        d[i] = 0
    else:
        d[i] = d[i - 1] + 1
        if i % 5 == 0:
            d[i] = min(d[i], d[i // 5] + 1)
        if i % 3 == 0:
            d[i] = min(d[i], d[i // 3] + 1)
        if i % 2 == 0:
            d[i] = min(d[i], d[i // 2] + 1)

print(d[x])
"""
# 문제 해설
# 이 문제는 잘 알려진 다이나믹 프로그래밍 문제이다. 피보나치 수열 문제를 도식화했던 것처럼 문제를 풀기 전에 함수가 호출되는 과정을 그림으로 그려보면 이해하는 데 도움이 된다.
# 예를 들어 X = 6일 때, 함수가 호출되는 과정을 그리면 다음과 같을 것이다. 확인해보면, 마찬가지로 f(2)와 같은 함수들이 동일하게 여러 번 호출되는 것을 확인할 수 있다.
# 이 문제에서 동일한 함수에서 구하는 값들은 동일해야 하므로 다이나믹 프로그래밍을 효과적으로 사용할 수 있다.
# ....
# 이제 문제에서 요구하는 내용을 점화식으로 표현해보자. 점화식 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야 하기 때문이다.
# -->> "a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1"
# -->> 따라서 이 점화식을 토대로 "보텀업 다이나믹 프로그래밍"으로 소스코드를 작성해보자.
# 실제 코드로 구현할 때는 1을 빼는 연산을 제외하고는 해당 수로 나누어떨어질 때에 한해서만 점화식을 적용할 수 있다.
# 더불어 두 수 중에서 단순히 더 작은 수를 구하고자 할 때에는 파이썬에서의 min() 함수를 이용하면 간단하다.

# 8-5.py 답안 예시
"""
# 정수 X를 입력받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
"""

# <3> 개미 전사
# 문제 해설
# 이 문제 또한 그림으로 도식화한 뒤에 생각하면 어렵지 않다. 예를 들어 N이 4이고 차례대로 식량이 1, 3, 1, 5만큼 들어 있다고 가정하자.
# 그렇다면 식량을 선택할 수 있는 경우의 수는 다음 그림처럼 8이다. 또한 7번째 경우에서 총 8만큼의 식량을 얻을 수 있기 때문에 정답은 8이다.
# ....
# ....
# -->> 그럼 이 문제의 '점화식'은 어떻게 세울까?
# -->> 처음 이 문제를 접했을 때는 문제 풀이를 위한 아이디어를 떠올리기 어려울 수 있지만 -->> "왼쪽부터 차례대로 식량창고를 턴다고 가정하면 어렵지 않게 점화식을 세울 수 있다."
# -->> 왼쪽부터 차례대로 식량창고를 털지 안 털지를 결정하는 경우와 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때, 단 2가지 경우에 대해서만 확인하면 된다.
# (a) (i - 1)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 없다.
# (b) (i - 2)번째 식량창고를 털기로 결정한 경우 현재의 식량창고를 털 수 있다.
# -->> 따라서 (a) 와 (b) 중에서 더 많은 식량을 털 수 있는 경우를 선택하면 된다.
# -->> 그림으로 보았을 때는 색칠한 식량창고에서 식량을 얻을 수 있는 것이다.
# -->> 여기서 알아둘 점은 i번째 식량창고에 대한 최적의 해를 구할 때 왼쪽부터 (i - 3)번째 이하의 식량 창고에 대한 최적의 해에 대해서는 고려할 필요가 없다는 점이다.
# -->> 예를 들어 d[i - 3]는 d[i - 1]과 d[i - 2]을 구하는 과정에서 이미 계산되었기 (고려되었기) 때문에, d[i]의 값을 구할 때는 d[i - 1]과 d[i - 2]만 고려하면 된다.
# -->> 따라서 i번째 식량창고에 있는 식량의 양이 k(i)라고 했을 때 점화식은 다음과 같다.
# -->> "a(i) = max(a(i - 2) + k(i) , a(i - 1))"
# 보텀업 방식의 풀이를 살펴보면 다음과 같다.

# 8-6.py 답안 예시
"""
# 정수 N을 입력받기
n = int(input())
# 모든 식량 정보 입력받기
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = array[0]
d[1] = max(d[0], array[1])
for i in range(2, n):
    d[i] = max(d[i - 2] + array[i], d[i - 1])

# 계산된 결과 출력
print(d[n - 1])
"""

# <4> 바닥 공사
# 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다.
# 태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해 채우고자 한다.
# ....
# ....
# ....                                                               "세로 x 가로"
# 이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2 x 3 크기의 바닥을 채우는 경우의 수는 5가지이다.
# 입력 조건 : * 첫째 줄에 N이 주어진다. (1 <= N <= 1,000)
# 출력 조건 : * 첫째 줄에 2 X N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.
# 입력 예시         출력 예시
#   3                  5

# my solution
"""
# 가로의 길이를 입력받기
n = int(input())

# DP 테이블을 선언해주자..!!
d = [0] * (n+1)
# '점화식'을 구해보자..!!
# -->> d[n] = d[n-2] ?? d[n -1] (x)
# -->> d[n] = d[n-1] + (d[n-2] + 2) (x)
# -->> d[n] = (d[n-1] * 1) + (d[n-2] * 2)
# -->> ok..!!
d[1] = 1
d[2] = 3
for i in range(3, n + 1):
    d[i] = (d[i-1] * 1) + (d[i-2] * 2)

print(d[n] % 796796)
"""
# 문제 해설
# 이 문제 또한 마찬가지로 다이나믹 프로그래밍의 기초 예제에서 빠질 수 없는 타일링 문제 유형이다. 다이나믹 프로그래밍 문제에서는 종종 결과를 어떤 수로 나눈 결과를 출력하라는 내용이 들어가 있는 경우가 많다.
# 이 문제에서도 796,796으로 나눈 나머지를 출력하라고 하는데, 이는 단지 결괏값이 굉장히 커질 수 있기 때문에 그런 것이다.
# 따라서 값을 계산할 때마다 특정한 수로 나눈 나머지만 취하면 된다.
# 이 문제 또한 그림으로 그려서 생각하면 어렵지 않게 풀 수 있다.
# 예를 들어 N이 3일 때 바닥을 덮개로 채울 수 있는 모든 경우의 수는 다음과 같다.
# -->> 또한 "왼쪽부터 차례대로" 바닥을 덮개로 채운다고 생각하면 어렵지 않게 점화식을 세울 수 있다. ( -->> 즉, "보텀업 방식"을 이용해라..!!)
# 1. 왼쪽부터 i - 1까지 길이가 덮개로 이미 채워져 있으면 2 x 1의 덮개를 채우는 하나의 경우밖에 존재하지 않는다.
# 2. 왼쪽부터 i - 2까지 길이가 덮개로 이미 채워져 있으면  1 x 2 덮개 2개를 넣는 경우, 혹은 2 x 2의 덮개 하나를 넣는 경우로 2가지 경우가 존재한다.
# 참고로 2 x 1 덮개 2개를 넣는 경우를 고려하지 않는 이유는 1.에서 이미 해당 경우가 고려되었기 때문이다.
# 또한 이 문제 역시 i번째 위치에 대한 최적의 해를 구할 때 왼쪽부터 (i - 3)번째 이하의 위치에 대한 최적의 해에 대해서는 고려할 필요가 없다.
# 왜냐하면 사용할 수 있는 덮개의 형태가 최대 2 x 2 크기의 직사각형 형태이기 때문이다. 다시 말해 바닥을 채울 수 있는 형태는 
# 위에서 언급한 경우밖에 없다. 따라서 다음과 같이 점화식을 세울 수 있다.
# -->> a(i) = a(i-1) + a(i-2) + a(i-2)
# -->> a(i) = a(i-1) + 2 * a(i-2)
# 왼쪽부터 N - 2까지 길이가 덮개로 이미 채워져 있는 경우 덮개를 채우는 방법은 2가지 경우가 있다.
# 이 두 방법은 서로 다른 것이므로, 결과적으로는 a(i)는 a(i-1) + a(i-2) + a(i-2)가 된다. 따라서 이를 간략히
# a(i) = a(i-1) + 2 * a(i-2)로 표현한 것이다.

# 8-7.py 답안 예시
"""
# 정수 N을 입력받기
n = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * (n+1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[1] = 1
d[2] = 3
for i in range(3, n + 1):
    d[i] = d[i - 1] + 2 * d[i - 2]

# 계산된 결과 출력
print(d[n] % 796796)
"""
# <5> 효율적인 화폐 구성

# my solution <<-- Wrong..!!

# 문제 해설
# 이 문제는 그리디에서 다루었던 거스름돈 문제와 거의 동일하다.
# 단지 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다.
# 그렇기 때문에 그리디 알고리즘을 사용했던 예시처럼 매번 가장 큰 화폐의 단위부터 처리하는 방법으로는 해결할 수 없고 다이나믹 프로그래밍을 이용해야 한다.
# 이번 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.
# 금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i), 화폐의 단위를 k라고 했을 때 다음과 같이 점화식을 작성할 수 있다.
# a(i-k)는 금액 (i-k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.
# * a(i-k)를 만드는 방법이 존재하는 경우 : a(i) = min(a(i), a(i-k) + 1)
# * a(i-k)를 만드는 방법이 존재하지 않는 경우 : a(i) = 10,001
# 이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서 가장 먼저 K의 크기만큼 리스트를 할당한다.
# 이후에 각 인덱스르 '금액'으로 고려하여 메모이제이션을 진행한다.
# 예를 들어 N =3, K =7이고, 각 화폐의 단위가 2, 3, 5 인 경우를 생각해보자.
# <step 0> "초기화": 각 인덱스에 해당하는 값으로는 10,001을 설정한다. 10,001은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미이다.
# 필자는 M의 최대 크기가 10,000이므로 불가능한 수로 10,001이라는 값을 설정했으며 이보다 더 큰 수여도 상관없다.
# 또한 0원인 경우, 화폐를 하나도 사용하지 않았을 때 만들 수 있으므로 0을 설정한다.
# 따라서 초기 리스트이 값은 다음과 같다.
# ....
# <step 1> "화폐 단위 : 2, 3, 5" 가장 먼저 첫 번째 화폐 단위인 2부터 확인한다.
# 앞서 언급한 점화식에 따라 다음과 같이 리스트가 갱신된다. 예를 들어 인덱스 2의 경우 1이라는 값을 가지는데, 이는 2원짜리 화폐 하나를 이용하여 2원을 만들 수 있다는 의미이다.
# 다시 말해 a(2) = a(0) + 1이다.
# 인덱스 4의 경우 2라는 값을 가지는데, 이는 2원짜리 화폐를 2개 이용하여 (2 + 2) = 4원을 만들 수 있다는 의미이다.
# 다시 말해 a(4) = a(2) + 1
# 몇 인덱스의 경우 10,001의 값을 그대로 가지는데, 이는 2원짜리 화폐를 가지고 구성할 수 없는 금액이기 때문이다.
# 예를 들어 인덱스 3의 경우 인덱스 1의 값이 10,001이므로 마찬가지로 10,001의 값을 가진다.
# ....
# <step 2> "화폐 단위 : 2, 3, 5" 이어서 화폐 단위 3을 확인한다. 앞서 언급한 점화식에 따라서 값을 도출하면 다음과 같이 리스트가 갱신된다.
# 예를 들어 a(5) = a(2) + 1로 2라는 값을 가진다. 이것은 2원짜리 화폐 1개, 3원짜리 화폐 1개로 (2 + 3) = 5원을 만들 수 있다는 의미가 된다.
# ....
# <step 3> "화폐 단위 : 2, 3, 5" ....
# ....

# 8-8.py 답안 예시
"""
# 정수 N, M을 입력받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[0] = 0
for i in range(n): # -->> 즉, 각각의 화폐단위 마다 반복문..!!
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001:  # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을  만드는 방법이 없는 경우.
    print(-1)
else:
    print(d[m])
"""


