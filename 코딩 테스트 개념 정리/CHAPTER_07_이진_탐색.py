# CHAPTER > 07 : 이진 탐색
# 탐색 범위를 반으로 좁혀가며 빠르게 탐색하는 알고리즘

# <1> 범위를 반씩 좁혀가는 탐색

# 순차 탐색
# 이번 장에서는 리스트 내에서 데이터를 매우 빠르게 탐색하는 이진 탐색 알고리즘에 대해서 공부하겠다.
# 이진 탐색에 대해서 알아보기 전에 -->> 가장 기본 탐색 방법인 순차 탐색에 대해 먼저 이해할 필요가 있다.
# 사실 지금까지 예제 문제에서 N개의 데이터가 있을 때, 그 데이터를 차례대로 하나씩 확인하여 어떠한 처리를 해준 경우가 많았는데
# 그 자체로도 이미 순차 탐색이라고 할 수 있다.
# 이와 같이 "순차 탐색(Sequential Search)"이란 -->> "리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법"이다.
# 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다.
# 리스트 내에 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 원소(데이터)를 찾을 수 있다는 장점이 있다.
# 다음은 순차 탐색으로 Dongbin을 찾는 과정이다.
# ....
# ....
# ....
# -->> 순차 탐색은 이름처럼 순차로 데이터를 탐색한다는 의미이다.
# -->> 리스트의 데이터에 하나씩 방문하며 특정한 문자열과 같은지 검사하므로 구현도 간단하다.
# -->> 순차 탐색은 정말 자주 사용되는데, 리스트에 특정 값의 원소가 있는지 체크할 때도 순차 탐색으로 원소를 확인하고, -->> 리스트 자료형에서 특정한 값을 가지는 원소의 개수를 세는 "count() 메서드"를 이용할 때도 -->> "내부에서는 순차 탐색이 수행된다."
# 순차 탐색을 파이썬 코드로 작성하면 다음과 같다.

# 7-1.py 순차 탐색 소스코드
"""
# 순차 탐색 소스코드 구현
def sequential_search(n, target, array):
    # 각 원소를 하나씩 확인하며
    for i in range(n):
        # 현재의 원소가 찾고자 하는 원소와 동일한 경우
        if array[i] == target:
            return i + 1 # 현재의 위치 반환(인덱스는 0부터 시작하므로 1 더하기)

print("생성할 원소 개수를 입력한 다음 한 칸 띄고 찾을 문자열을 입력하시오.")
input_data = input().split()
n = int(input_data[0]) # 원소의 개수
target = input_data[1] # 찾고자 하는 문자열

print("앞서 적은 원소 개수만큼 문자열을 입력하시오. 구분은 띄어쓰기 한 칸으로 합니다.")
array = input().split()

# 순차 탐색 수행 결과 출력
print(sequential_search(n, target, array))
"""
# ....
# -->> 이처럼 순차 탐색은 데이터 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 한다는 점이 특징이다.
# -->> 따라서 데이터의 개수가 N개일 때 최대 N번의 비교 연산이 필요하므로 순차 탐색의 최악의 경우 시간 복잡도는 O(N)이다.

# 이진 탐색 : 반으로 쪼개면서 탐색하기
# 드디어 본론인 이진 탐색을 공부해보자. -->> "이진 탐색(Binary Search)"은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘이다.
# 데이터가 무작위일 때는 사용할 수 없지만, -->> 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다는 특징이 있다. -->> 이진 탐색은 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다.
# 이미 정렬된 10개의 데이터 중에서 값이 4인 원소를 찾는 예시를 살펴보자.
# <step 1> 시작점과 끝점을 확인한 다음 둘 사이에 중간점을 정한다. 중간점이 실수일 때는 소수점 이하를 버린다.
# .... 끝점을 [4]의 이전인 [3]으로 옮긴다.
# <step 2> .... 따라서 시작점을 [2]로 옮긴다.
# <step 3> 시작점은 [2], 끝점은 [3]이다. 이때 중간점은 (2.5에서 소수점 이하를 버려서) [2]이다. 중간점에 위치한 데이터 4는 찾으려는 데이터 4와 동일하므로 이 시점에서 탐색을 종료한다.
# -->> 전체 데이터의 개수는 10개지만, -->> 이진 탐색을 이용해 총 3번의 탐색으로 원소를 찾을 수 있었다. -->> 이진 탐색은 한 번 확인할 때마다 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 "시간 복잡도가 O(logN)이다."
# -->> "절반씩 데이터를 줄어들도록 만든다는 점은 앞서 다룬 퀵 정렬과 공통점이 있다."
# .... 예를 들어 데이터의 개수가 32개일 때, 1단계만 거치면 이상적인 경우 16개가량의 데이터만 남게 될 것이다. 2단계를 거치면 8개가량의 데이터만 확인하면 된다.
# -->> 즉, 단계마다 2로 나누는 것과 동일하므로 연산 횟수는 O(logN)의 빅오 표기법을 갖는다고 볼 수 있습니다..!!
# -->> 이진 탐색을 구현하는 방법에는 2가지가 있는데 1. '하나'는 '재귀 함수'를 '이용'하는 '방법'이고, 2. '다른 하나'는 '단순하게 반복문을 이용'하는 '방법'이다.
# 먼저 재귀 함수를 이용한 코드를 보자.

# 7-2.py 재귀 함수로 구현한 이진 탐색 코드
"""
# 이진 탐색 소스코드 구현(재귀 함수)
def binary_search(array, target, start, end):
    if start > end :
        return None
    mid = (start + end) // 2
    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target : 
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)

# n(원소의 개수)과 target(찾고자 하는 타겟)을 입력받기
n, target = list(map(int, input().split()))
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
"""
# .... ->> 이처럼 같은 기능이라고 하더라도 다양한 방법으로 구현이 가능하다는 점을 기억하자.
# 다음은 단순하게 반복문을 사용한 코드이다. 실행 결과는 재귀 함수와 같으므로 생략한다.

# 7-3.py 반복문으로 구현한 이진 탐색 소스코드
"""
# 이진 탐색 소스코드 구현(반복문)
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1
    return None

# n(원소의 개수)과 target(찾고자 하는 타켓)을 입력받기
n, target = list(map(int, input().split()))
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
"""

# 코딩 테스트에서의 이진 탐색
# 단순히 앞의 코드를 보고 이진 탐색이 단순하다고 느낄 수 있지만, -->> 정작 참고할 소스코드가 없는 상태에서 이진 탐색의 소스코드를 구현하는 것은 상당히 어려운 작업이 될 수 있다.
# 존 벤틀리의 말에 따르면 제대로 이진 탐색 코드를 작성한 프로그래머는 10% 내외라 할 정도로 실제 구현은 까다롭다.
# ....
# -->> "'''이진 탐색''''은 코딩 테스트에서 단골로 나오는 문제이니 가급적 외우길 권한다."
# -->> 이진 탐색의 원리는 다른 알고리즘에서도 폭넓게 적용되는 원리와 유사하기 때문에 매우 중요하다.
# -->> 또, 높은 난이도의 문제에서는 이진 탐색 알고리즘이 다른 알고리즘과 함께 사용되기도 한다.
# -->> 더불어 코딩 테스트의 이진 탐색 문제는 탐색 범위가 큰 상황에서의 탐색을 가정하는 문제가 많다. 따라서 탐색 범위가 2000만을 넘어가면 이진 탐색으로 문제에 접근해보길 권한다.
# -->> 처리해야할 데이터의 개수나 값이 1000만 단위 이상으로 넘어가면 이진 탐색과 같이 O(logN)의 속도를 내야 하는 알고리즘을 떠올려야 문제를 풀 수 있는 경우가 많다는 점을 기억하자.

# 트리 자료구조
# 이진 탐색은 전제 조건이 데이터 정렬이다. 
# 예를 들어 동작하는 프로그램에서 데이터를 정렬해두는 경우가 많으므로 이진 탐색을 효과적을 사용할 수 있다.
# -->> 데이터베이스는 -->> "내부적으로 대용량 데이터 처리에 적합한 트리(Tree) 자료구조를 이용"하여 -->> "항상 데이터가 정렬되어 있다."
# 따라서 데이터베이스에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어서 데이터가 많아도 탐색하는 속도가 빠르다.
# 그렇다면 트리 자료구조가 무엇인지 간단하게 알아보자.
# ....
# '트리 자료구조'는 -->> '그래프 자료구조의 일종으로' 데이터 베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용된다.
# 트리 자료구조는 몇가지 주요한 특징이 있다.
# ....
# * 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.
# -->> 정리하자면 큰 데이터를 처리하는 소프트웨어는 대부분 데이터를 '트리 자료구조'로 '저장'해서 이진 탐색과 같은 탐색 기법을 이용해 빠르게 탐색이 가능하다.
# 그렇다면 이런 트리 구조를 이용하면 정확히 어떤 방식으로 항상 이진 탐색이 가능한 걸까?

# 이진 탐색 트리
# -->> 트리 자료구조 중에서 가장 간단한 형태가 '이진 탐색 트리'이다.
# -->> 이진 탐색 트리란 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.
# 이진 탐색 트리를 설명하는 동안 코드를 배제할 테니 편하게 다음 그림을 보자.
# ....
# 이진 탐색 트리는 다음과 같은 특징을 지닌다.
# * 부모 노드보다 왼쪽 자식 노드가 작다.
# * 부모 노드보다 오른쪽 자식 노드가 크다.
# 그림에서 루트를 포함한 일부만 다시 살펴보자.
# 좀 더 간단하게 표현하면 "왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드"가 성립해야지 이진 탐색 트리라 할 수 있다.
# 그림에서도 17 < 30 < 48로 성립한다는 걸 알 수 있다.
# 이진 탐색 트리에 데이터를 넣고 빼는 방법은 알고리즘보다는 자료구조에 가까우며, 이진 탐색 트리 자료구조를 구현하도록 요구하는 문제는 출제 빈도가 낮으므로,
# 이 책에서는 이진 탐색 트리를 구현하는 방법은 소개하지는 않는다.
# -->> 따라서 '이진 탐색 트리가 미리 구현되어 있다고 가정하고' -->> '다음 그림과 같은 이진 탐색 트리에서 ''데이터를 조회하는 과정''만 살펴보겠다.'
# 다음은 찾는 원소가 37일 때 동작하는 과정이다.
# ....
# ....
# ....
# 이진 탐색 트리에서 데이터 조회는 동작 원리만 살펴보면 간단하게 느껴진다.
# 공식에 따라 루트 노드부터 왼쪽 자식 노드와 혹은 오른쪽 자식 노드로 이동하며 반복적으로 방문한다.
# 자식 노드가 없을 때까지 원소를 찾지 못했다면, 이진 탐색 트리에 원소가 없는 것이다.
# 짧게 3단계로 살펴봤지만 아무리 노드가 많아도 이진 탐색 트리는 이 과정을 반복하는 것에 불과하니 위의 과정 그림을 이해하면 충분하다.

# 빠르게 입력받기
# -->> 이진 탐색 문제는 입력 데이터가 많거나, 탐색 범위가 매우 넓은 편이다.
# -->> 예를 들어 데이터의 개수가 1000만 개를 넘어가거나 탐색 범위의 크기가 1000억 이상이라면 이진 탐색 알고리즘을 의심해 보자.
# -->> 그런데 이렇게 입력 데이터의 개수가 많은 문제에 input() 함수를 사용하면 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있다.
# -->> 이처럼 입력 데이터가 많은 문제는 sys 라이브러리의 readline() 함수를 이용하면 시간 초과를 피할 수 있다.
# -->> 때로는 코딩 테스트 출제자가 아예 sys 라이브러리를 사용하기를 권고하는 문장을 문제에 적어 놓기도 한다.
# sys 라이브러리는 다음과 같은 방식으로 사용하며 한 줄씩 입력받는다.

# 7-4.py 한 줄 입력받아 출력하는 소스코드
"""
import sys
# 하나의 문자열 데이터 입력받기
input_data = sys.stdin.readline().rstrip()

# 입력받은 문자열 그대로 출력
print(input_data)
"""
# sys 라이브러리를 사용할 때는 한 줄 입력받고 나서 rstrip() 함수를 꼭 호출해야 한다.
# 소스코드에 readline()으로 입력하면 입력 후 엔터(Enter)가 줄 바꿈 기호로 입력되는데, 이 공백 문자를
# 제거하려면 rstrip() 함수를 사용해야 한다.
# 코드가 짧으니, 관행적으로 외워서 사용하자. 또한 readline() 함수를 더 간결하게 사용하는 팁은 부록에서 추가로 다루고 있다.
# 이제 실전 예제를 풀어보며 이진 탐색을 어떻게 사용하는지 알아보자.

# <2> 부품 찾기

# my solution
"""
import sys
n = int(input())
bp_list = list(map(int, sys.stdin.readline().rstrip().split()))
m = int(input())
yc_list = list(map(int, sys.stdin.readline().rstrip().split()))

bp_list.sort(reverse = False) # 일단 부품 리스트를 오름차순을 정렬시켜주자..!!

def binary_search(array, target, start, end):
    if start > end :
        return False
    mid = (start + end) // 2
    if array[mid] == target :
        return True
    elif array[mid] > target :
        return binary_search(array, target, start, mid - 1)
    else:
        return binary_search(array, target, mid + 1, end)

for yc in yc_list:
    if binary_search(bp_list, yc, 0, len(bp_list) - 1) == True :
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""

# 문제 해설
# 이 문제는 여러 방법으로 해결할 수 있다. 여기서는 가장 먼저 이진 탐색 알고리즘으로 풀이할 텐데,
# 이처럼 다량의 데이터 검색은 이진 탐색 알고리즘을 이용해 효과적으로 처리할 수 있다.
# -->> 먼저 매장 내 N개의 부품을 번호를 기준으로 정렬하자. -->> 그 이후에 M개의 찾고자 하는 부품이 각각 매장에 존재하는지 검사하면 된다.
# 따라서 이렇게 문제를 풀면, 부품을 찾는 과정에서 최악의 경우 시간 복잡도 O(M * logN)의 연산이 필요하므로 이론상 최대 약 200만 번의 연산이 이루어진다고 분석할 수 있다.
# 오히려 N개의 부품을 정렬하기 위해서 요구되는 시간 복잡도 O(N * logN)이 이론적으로 최대 약 2,000만으로 더욱더 많은 연산이 필요한 것을 알 수 있다.
# -->> 결과적으로 이진 탐색을 사용하는 문제 풀이 방법의 경우 시간 복잡도는 O((M+N)*logN)이다.
# 우리가 지금까지 배운 이진 탐색 알고리즘을 이용한 풀이는 다음 소스코드와 같다.

# 7-5.py 답안 예시(이진 탐색)
"""
# 이진 탐색 소스코드 구현(반복문)
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1
    return None

# N(가게의 부품 개수) 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력
array = list(map(int, input().split()))
array.sort(reverse = False) # 이진 탐색을 수행하기 위해 사전에 정렬 수행
# M(손님이 확인 요청한 부품 개수) 입력
m = int(input())
# 손님이 확인 요청한 전체 부품 번호를 공백으로 구분하여 입력
x = list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인
for i in x:
    result = binary_search(array, i, 0, n - 1)
    if result != None:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# -->> 이진 탐색 말고도 계수 정렬의 개념을 이용하여 문제를 풀 수도 있다. 모든 원소의 번호를 포함할 수 있는 크기의 리스트를 만든 뒤에, 리스트의 인덱스에 직접 접근하여 특정한 번호의 부품이 매장에 존재하는지 확인하면 된다.

# 7-6.py 답안 예시 (계수 정렬)
"""
# N(가게의 부품 개수)을 입력받기
n = int(input())
array = [0] * 1000001

# 가게에 있는 전체 부품 번호를 입력받아서 기록
for i in input().split():
    array[int(i)] = 1

# M(손님이 요청한 부품 개수)을 입력받기
m = int(input())
# 손님이 요청한 전체 부품 번호를 공백을 구분하여 입력받기
x = list(map(int, input().split()))

for i in x:
    # 해당 부품이 존재하는지 확인
    if array[i] == 1:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# -->> 또는 이 문제는 단순히 특정한 수가 한 번이라도 등장했는지를 검사하면 되므로 집합 자료형을 이용해서 문제를 해결할 수 있다.
# -->> set() 함수는 집합 자료형을 초기화할 때 사용한다.
# -->> 이러한 집합 자료형은 단순히 특정한 데이터가 존재하는지 검사할 때에 매우 효과적으로 사용할 수 있다.
# 다음의 소스코드가 간결한 측면에서는 가장 우수하다.

# 7-7.py 답안 예시(집합 자료형 이용)
"""
# N(가게의 부품 개수)을 입력받기
n = int(input())
# 가게에 있는 전체 부품 번호을 입력받아서 집합(set) 자료형에 기록
array =set(map(int, input().split()))

# M(손님이 확인 요청한 부품 개수)을 입력받기
m = int(input())
# 손님이 확인 요청한 전체 부품 번호를 공백을 구분하여 입력
x = list(map(int, input().split()))

# 손님이 확인 요청한 부품 번호를 하나씩 확인
for i in x:
    if i in array:
        print("yes", end = " ")
    else:
        print("no", end = " ")
"""
# 하지만 이진 탐색으로도 충분히 풀 수 있으며, 경험이 많지 않으면 이진 탐색을 이용한 해법보다 집합 자료형을 이용한 해법을 떠올리기 어려울 수 있고,
# 혹은 그 반대일 수도 있다. 따라서 동일한 문제를 여러 가지 방법으로 풀 수 있으며, 이 문제는 3가지 방법을 이용해 모두 효과적으로 풀 수 있다는 점을 기억하자.

# <3> 떡복이 떡 만들기

# my solution -->> "제 풀이는 시간 초과 판정을 받을 확률이 높은 풀이입니다..!!"
"""
n, m = map(int, input().split())
n_list = list(map(int, input().split()))
max_height = 0
while True:
    sum = 0
    for i in range(0,len(n_list)): # 시간 복잡도 : O(N) -->> 즉, 최대 100만번의 연산을 한다 while문 한 루프동안..!!
        sum += (n_list[i] - max_height) if n_list[i] >= max_height else 0
    if sum > m:
        max_height += 1
        continue
    elif sum == m:
        break
    else:
        max_height -= 1
        break

print(max_height)
"""

# 문제 해설 
# 전형적인 이진 탐색 문제이자, 파라메트릭 서치(Parametric Search)유형의 문제이다.
# 파라메트릭 서치는 최적화 문제를 -->> 결정 문제로(* 결정 문제는 '예' 혹은 '아니요'로 답하는 문제를 말한다.) 바꾸어 해결하는 기법이다.
# '원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제'에 주로 파라메트릭 서치를 사용한다.
# 예를 들어 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진 탐색으로 결정 문제를 해결하면서 범위를 좁혀갈 수 있다.
# 코딩 테스트나 프로그래밍 대회에서는 보통 파라메트릭 서치 유형은 '이진 탐색'을 이용하여 해결한다.
# -->> "이 문제의 풀이 아이디어는 의외로 간단한데 적절한 높이를 찾을 때까지 절단기의 높이 H를 반복해서 조정하는 것이다."
# -->> 그래서 '현재 이 높이로 자르면 조건을 만족할 수 있는가?'를 확인한 뒤에 조건의 만족 여부('예' 혹은 '아니요')에 따라서 탐색 범위를 좁혀서 해결할 수 있다.
# -->> "범위를 좁힐 때는 이진 탐색의 원리를 이용하여 절반씩 탐색 범위를 좁혀나간다."
# 절단기의 높이(탐색 범위)는 1부터 10억까지의 정수 중 하나인데, 이처럼 큰 수를 보면 당연하다는 듯이 가정 먼저 이진 탐색을 떠올려야 한다.
# 이 문제에서 절단기의 높이 범위가 한정적이었다면 순차 탐색으로도 해결할 수 있지만, 현재 문제에서 절단기의 높이는 최대 10억까지의 정수이므로 순차 탐색은 분명 시간 초과를 받을 것이다.
# -->> 반면에 높이 H를 이진 탐색으로 찾는다면, 대략 31번 만에 경우의 수를 모두 고려할 수 있다.
# 이떄 떡의 개수 N이 최대 100만 개이므로 이진 탐색으로 절단기의 높이 H를 바꾸면서, 바꿀 때마다 모든 떡을 체크하는 경우 대략 최대 3,000만 번 정도의 연산으로 문제를 풀 수 있다.
# 문제의 시간 제한은 2초이므로 최악의 경우 3,000만 번 정도의 연산이 필요하다면 아슬아슬하게 시간 초과를 받지 않고 정답 판정을 받을 것이다.
# 그렇다면 구체적으로 어떻게 이 문제를 이진 탐색으로 해결할 수 있을까?
# 절단기의 적절한 높이 H를 정하는 과정을 살펴보자.
# 다음의 예시를 살펴보자.
# 필요한 떡의 길이가 6cm이고, 떡의 높이가 차례대로 19, 15, 10, 17cm이다.(이후 cm는 생략한다.)
# -->> 당연하지만, 절단기의 높이 H는 0부터 가장 긴 떡의 길이 안에 있어야만 떡을 자를 수 있다.
# <step 1> 시작점은 0, 끝점은 가장 긴 떡의 길이 (19)로 설정한다. 0과 19 사이의 중간점 9을 절단기 높이 H로 설정하면 얻을 수 있는 떡의 합은 (10 + 6 + 1 + 8) = 25이다.
# 필요한 떡의 길이가 6보다 크기 때문에 시작점을 증가시킨다.
# <step 2> 시작점을 10으로 옮긴다. 끝점은 여전히 19이므로 중간점은 14이다. 절단기 높이를 14로 설정하면 얻을 수 있는 떡의 합은 (5 + 1 + 3) = 9 이다.
# 여전히 필요한 떡의 길이인 6보다 크기 때문에 시작점을 증가시킨다.
# <step 3> 현재 시작점은 15, 끝점은 19, 중간점은 17이므로 얻을 수 있는 떡의 합은 2이다. 필요한 떡의 길이인 6보다 작기 때문에 끝점을 감소시킨다.
# 여기서 잠깐 >
# [step 2]에서 중간점에 1을 더한 값인 15로 설정한다. 이미 이전 단계에서 14(중간점)인 경우를 처리했으므로 이번 단계에서는 15부터 본다는 의미이다.
# <step 4> 현재 시작점은 15, 끝점은 16, 중간점은 15이므로 얻을 수 있는 떡의 합은 (4 + 2) = 6이다. 필요한 떡의 길이인 6과 동일하다.
# 이러한 이진 탐색 과정을 반복하면 답을 도출할 수 있다.
# 중간점의 값은 시간이 지날수록 '최적화된 값'을 찾기 때문에, -->> "과정을 반복하면서 얻을 수 있는 떡의 길이의 합이 필요한 떡의 길이보다 크거나 같을 때마다 결괏값을 중간점(MID) 값으로 갱신해주면 된다."
# 또한 이 문제에서는 현재 얻을 수 있는 떡복이의 양에 따라서 자를 위치를 결정해야 하기 때문에 이를 재귀적으로 구현하는 것은 귀찮은 작업이 될 수 있다.
# 따라서 일반적으로는 이 문제와 같은 파라메트릭 서치 문제 유형은 이진 탐색을 재귀적으로 구현하지 않고 반복문을 이용해 구현하면 더 간결하게 문제를 풀 수 있다.
# 전체 소스코드는 다음과 같다.

# 7-8.py 답안 예시
"""
# 떡의 개수(N)와 요청한 떡의 길이(M)을 입력받기
n, m = list(map(int, input().split()))
# 각 떡의 개별 높이 정보를 입력받기
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행(반복적)
result = 0
while (start <= end):
    total = 0
    mid = (start + end) // 2
    for x in array:
        # 잘랐을 때 떡의 양 계싼
        total += (x - mid) if x >= mid else 0
    # 떡의 양이 부족한 경우 더 많이 자르기(왼쪽 부분 탐색)
    if total < m :
        end = mid - 1
    elif total == m :
        result = mid
        break
    elif total > m :
        result = mid
        start = mid + 1

print(result)
"""

        