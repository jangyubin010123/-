# 07 > 정규 표현식
# : 필자는 '정규 표현식'을 이 책 <<점프 투 파이썬>>에 포함시켜야 할지 오랜시간 고민했다.
# 왜냐하면 정규 표현식은 꽤 오랜 기간 코드를 작성해 온 프로그래머라도 잘 모를 수 있는 고급 주제여서 초보자를 대상으로 하는 이 책에는 어울리지 않을 수 있기 때문이다.
# 하지만 정규 표현식을 배워 익히기만 하면 아주 달콤한 열매를 맛볼 수 있다. 그래서 파이썬 하우투를 참고하여 그곳에서 소개하는 수준의 내용만이라도 독자들이 이해하고 사용할 수 있도록 노력했다.
# 여러분이 정규 표현식을 잘 다루면 파이썬 외에 또 하나의 강력한 무기를 얻게 되는 것이다.
# 다시 말하지만 프로그래밍 입문자가 이해하기에는 어려운 내용이니 부담 갖지 말고 편하게 읽어 주기 바란다.
"""
07-1 정규 표현식 살펴보기
07-2 정규 표현식 시작하기
07-3 강력한 정규 표현식의 세계로
"""

# "07-1 정규 표현식 살펴보기"

# -->> "정규 표현식(Regular Expressions)"은 -->> "복잡한 문자열을 처리할 때 사용하는 기법으로,"
# 파이썬만의 고유 문법이 아니라 문자열을 처리하는 모든 곳에서 사용한다.
# 정규 표현식을 배우는 것은 파이썬을 배우는 것과는 또 다른 영역의 과제이다.

# 정규 표현식은 왜 필요한가?
# 다음과 같은 문제가 주어졌다고 가정해 보자.

# -->> "주민등록번호를 포함하고 있는 텍스트가 있다. 이 텍스트에 포함된 모든 주민등록번호의 뒷자리를 * 문자로 변경해 보자."

# 우선 정규식을 전혀 모르면 다음과 같은 순서로 프로그램을 작성해야 할 것이다.

# 1. 전체 텍스트를 공백 문자로 나눈다(split).
# 2. 나뉜 단어가 주민등록번호 형식인지 조사한다.
# 3. 단어가 주민등록번호 형식이라면 뒷자리를 *로 변경한다.
# 4. 나뉜 단어를 다시 조립한다.

# 이를 구현한 코드는 아마도 다음과 같을 것이다.
'''
data ="""
park 800905-1049118
kim  700905-1059119 
""" # 전체 텍스트

result = []
for line in data.split("\n"):
    word_result = []
    for word in line.split(" "): # <<-- 공백 문자마다 나누기
        if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit():
            word = word[:6] + "-" + "*******"
        word_result.append(word)
    result.append(" ".join(word_result)) # <<-- 나눈 단어 조립하기
print("\n".join(result))
'''
# 결괏값:
# park 800905-*******
# kim 700905-*******

# 반면에 정규식을 사용하면 다음처럼 훨씬 간결하고 직관적인 코드를 작성할 수 있다. 아직 정규식 사용 방법을 배우지 않았으니 눈으로만 살펴보자.
'''
import re # <<-- 정규 표현식을 사용하기 위한 re 모듈

data = """
park 800905-1049118
kim  700905-1059119
"""

pat = re.compile("(\d{6})[-]\d{7}")
print(pat.sub("\g<1>-*******",data))
'''
# 정규 표현식을 사용하면 이렇게 간단한 예제에서도 코드가 상당히 간결해진다.
# -->> "만약 찾으려는 문자열 또는 바꾸어야 할 문자열의 규칙이 매우 복잡하다면 정규식의 효용은 더 커지게 된다."
# 이제부터 정규 표현식의 기초부터 심화 부분까지 차근차근 알아보자.

# "07-2 정규 표현식 시작하기"

# 정규 표현식의 기초, 메타 문자
# 정규 표현식에서 사용하는 메타 문자(meta characters)에는 다음과 같은 것이 있다.
# (-->> * '메타 문자'란 '원래 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는 문자'를 말한다.)

# -->> ".^$*+?{}[]\|()"

# 정규 표현식에 위 메타 문자를 사용하면 특별한 의미를 갖게 된다.

# 자, 그러면 가장 간단한 정규 표현식부터 시작해 각 메타 문자의 의미와 사용법을 알아보자.

# 문자 클래스 []
# -->> "우리가 가장 먼저 살펴볼 메타 문자는 바로 '문자 클래스'(character class)인 '[]'이다." 문자 클래스로 만들어진 정규식은 '[]사이의 문자들과 매치'라는 의미를 갖는다.
# (* 문자 클래스를 만드는 메타 문자인 [] 사이에는 어떤 문자도 들어갈 수 있다.)
# 즉 정규 표현식이 [abc]라면 이 표현식의 의미는 'a, b, c 중 한 개의 문자와 매치'를 뜻한다.
# 이해를 돕기 위해 문자열 "a", "before", "dude"가 정규식 [abc]와 어떻게 매치되는지 살펴보자.
# 정규식 : [abc]
# 문자열 : "a", "before", "dude"
# 매치 여부 : Yes, Yes, No
# 설명 : 
# "a"는 정규식과 일치하는 문자인 "a"가 있으므로 매치
# "before"는 정규식과 일치하는 문자인 "b"가 있으므로 매치
# "dude"는 정규식과 일치하는 문자인 a, b, c 중 어느 하나라도 포함하고 있지 않으므로 매치되지 않음
# -->> "[] 안의 두 문자 사이에 하이픈(-)을 사용하면 두 문자 사이의 범위(From-To)를 의미한다."
# 예를 들어 [a-c]라는 정규 표현식은 [abc]와 동일하고
# [0-5]는 [012345]와 동일하다.
# 오른쪽은 하이픈(-)을 사용한 문자 클래스의 사용 예이다.  -->>  -[a-zA-Z] : 알파벳 모두,  -[0-9] : 숫자
# 문자 클래스([]) 안에는 어떤 문자나 메타 문자도 사용할 수 있지만
# 주의해야할 메타 문자가 1가지 있다. 그것은 바로 ^인데, 문자 클래스 안에 ^ 메타 문자를 사용할 경우에는 반대(not)라는 의미를 가진다. 
# -->> "예를 들어 [^0-9]라는 정규 표현식은 숫자가 아닌 문자만 매치된다."

# 점프 투 파이썬 : "자주 사용하는 문자 클래스"
# -->> "[0-9] 또는 [a-zA-Z] 등은 무척 자주 사용하는 정규 표현식이다." -->> "이렇게 자주 사용하는 정규식은 별도의 표기법으로 표현할 수 있다."
# 다음을 기억해 두자.

# 정규 표현식                   문자
# \d        : 숫자와 매치, [0-9]와 동일한 표현식이다.
# \D        : 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식이다.
# \s        : whitespace 문자(space 나 tab처럼 공백을 표현하는 문자)와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈칸은 공백 문자(space)를 의미한다.
# \S        : whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식이다.
# \w        : 문자 + 숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식이다.
# \W        : 문자 + 숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식이다.

# -->> "대문자로 사용된 것은 소문자의 반대임을 추측할 수 있다."

# Dot(.)
# -->> "정규 표현식의 Dot(.) 메타 문자는 줄바꿈 문자인 \n을 제외한 모든 문자와 매치됨을 알 수 있다."
# ....
# 다음 정규식을 보자
# (ex)
# a.b <<-- a와 b사이에 줄바꿈 문자를 제외한 어떤 문자가 들어가도 모두 매치
# 위 정규식의 의미는 오른쪽과 같다. 즉 a와 b라는 문자 사이에 어떤 문자가 들어가도 모두 매치된다는 의미이다. -->> "a + 모든 문자 + b"
# 이해를 돕기 위해 문자열 "aab", "a0b", "abc"가 정규식 a.b와 어떻게 매치되는지 살펴보자.
# 정규식 : a.b
# 문자열 : "aab", "a0b", "abc"
# 매치 여부 : Yes, Yes, No
# 설명 : 
# "aab"는 가운데 문자 "a"가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치
# "a0b"는 가운데 문자 "0"이 모든 문자를 의미하는 .과 일치하므로 정규식과 매치
# "abc"는 "a" 문자와 "b" 문자 사이에 어떤 문자라도 하나는 있어야 하는 이 정규식과 일치하지 않으므로 매치되지 않음

# 다음 정규식을 보자

# a[.]b <<-- a와 b사이에 Dot(.)문자가 있으면 매치

# 이 정규식의 의미는 오른쪽과 같다. 따라서 정규식 a[.]b는 "a.b" 문자열과 매치되고, "a0b" 문자열과는 매치되지 않는다.    -->> "a + Dot(.)문자 + b"
# (* 만약 앞에서 살펴본 문자 클래스([]) 안에 Dot(.) 메타 문자가 사용된다면 이것은 '모든 문자'라는 의미가 아닌 문자 . 그대로를 의미한다. 혼동하지 않도록 주의하자.)

# 반복(*)
# 다음 정규식을 보자.

# ca*t <<-- * 문자 바로 앞에 있는 a가 0번 이상 반복되면 매치

# 이 정규식에는 반복을 의미하는 * 메타 문자가 사용되었다.
# 여기에서 사용한 *은 * 바로 앞에 있는 문자 a가 0부터 무한대로 반복될 수 있다는 의미이다.
# (* 여기에서 * 메타 문자의 반복 개수가 무한대라고 표현했는데 사실 메모리 제한으로 2억 개 정도만 가능하다고 한다.)
# 즉 다음과 같은 문자열이 모두 매치된다.
# 정규식 : ca*t
# 문자열 : "ct", "cat", "caaat"
# 매치 여부 : Yes, Yes, Yes
# 설명 : 
# "a"가 0번 반복되어 매치
# "a"가 0번 이상 반복되어 매치(1번 반복)
# "a"가 0번 이상 반복되어 매치(3번 반복)

# 반복(+)
# 반복을 나타내는 또 다른 메타 문자로 +가 있다. +는 최소 1번 이상 반복될 때 사용한다.
# 즉 *가 반복 횟수 0부터라면 +는 반복 횟수 1부터인 것이다.
# 다음 정규식을 보자.

# ca+t <<-- + 문자 바로 앞에 있는 a가 1번 이상 반복되면 매치

# 위 정규식의 의미는 오른쪽과 같고, 정규식에 대한 매치 여부는 다음 표와 같다.       -->> "c + a(1번 이상 반복) + t"
# 정규식 : ca+t
# 문자열 : "ct", "cat", "caaat"
# 매치 여부 : No, Yes, Yes
# 설명 :
# "a"가 0번 반복되어 매치되지 않음
# "a"가 1번 이상 반복되어 매치(1번 반복)
# "a"가 1번 이상 반복되어 매치(3번 반복)

# "반복({m,n}, ?)"
# -->> "여기에서 잠깐 생각해 볼 게 있다. 반복 횟수를 3회만 또는 1회부터 3회까지만으로 제한하고 싶을 수도 있지 않을까?"
# -->> "{} 메타 문자를 사용하면 반복 횟수를 고정할 수 있다."
# -->> "{m, n} 정규식을 사용하면 반복 횟수가 m부터 n까지 매치할 수 있다."
# 또한 m 또는 n을 생략할 수 있다. 만약 {3,}처럼 사용하면 반복 횟수가 3 이상인 경우이고, {,3}처럼 사용하면 반복 횟수가 3 이하를 의미한다.
# 생략된 m은 0과 동일하며, 생략된 n은 무한대(2억 개 미만)의 의미를 갖는다.
# (* {1,}은 +와 동일하고, {0,}은 *와 동일하다.)
# {}을 사용한 몇 가지 정규식을 살펴보자.

# 1. {m}

# ca{2}t <<-- a가 2번 반복되면 매치

# 위 정규식의 의미는 오른쪽과 같고, 정규식에 대한 매치 여부는 다음 표와 같다.       -->> "c + a(반드시 2번 반복) + t"
# 정규식 : ca{2}t
# 문자열 : "cat", "caat"
# 매치 여부 : No, Yes
# 설명 : 
# "a"가 1번만 반복되어 매치되지 않음
# "a"가 2번 반복되어 매치

# -->> "2. {m, n}"

# ca{2, 5}t <<-- a가 2 ~ 5번 반복되면 매치

# 위 정규식의 의미는 오른쪽과 같고, 정규식에 대한 매치 여부는 다음 표와 같다.       -->> "c + a(2 ~ 5번 반복) + t"
# 정규식 : ca{2, 5}t
# 문자열 : "cat", "caat", "caaaaat"
# 매치 여부 : No, Yes, Yes
# 설명 : 
# "a"가 1번 반복되어 매치되지 않음
# "a"가 2번 반복되어 매치
# "a"가 5번 반복되어 매치

# 3. ?
# 반복은 아니지만 이와 비슷한 개념으로 ?이 있다.
# ? 메타 문자가 의미하는 것은 {0, 1}이다.
# 다음 정규식을 보자.

# ab?c <<-- b가 0~1번 사용되면 매치

# 위 정규식의 의미는 오른쪽과 같고, 정규식에 대한 매치 여부는 다음 표와 같다.       -->> "a + b(있어도 되고 없어도 된다) + c"
# 정규식 : ab?c
# 문자열 : "abc", "ac"
# 매치 여부 : Yes, Yes
# 설명 :
# "b"가 1번 사용되어 매치
# "b"가 0번 사용되어 매치
# -->> "즉 b 문자가 있거나 없거나 둘 다 매치되는 경우이다."
# *, +, ? 메타 문자는 모두 {m,n} 형태로 고쳐 쓰는 것이 가능하지만       -->> * : {0,},  + : {1,},   ? : {0,1}
# 가급적 이해하기 쉽고 표현도 간결한 *, +, ? 메타 문자를 사용하는 것이 좋다.
# 지금까지 아주 기초적인 정규 표현식에 대해서 알아보았다.
# 알아야 할 것들이 아직 많이 남아있지만 -->> "그에 앞서서 파이썬으로 이러한 정규 표현식을 어떻게 사용할 수 있는지 먼저 알아보기로 하자."

# "파이썬에서 정규 표현식을 지원하는 re 모듈"
# 파이썬은 정규 표현식을 지원하기 위해 re(regular expression의 약어) 모듈을 제공한다.
# re 모듈은 파이썬을 설치할 때 자동으로 설치되는 기본 라이브러리로 사용 방법은 다음과 같다.
"""
>>> import re
>>> p = re.compile("ab*")
"""
# re.compile을 사용하여 정규 표현식(위 예에서는 ab*)을 컴파일한다.
# 're.compile의 결과로 돌려주는 객체 p'('컴파일 된 패턴 객체')를 사용하여 그 이후의 작업을 수행할 것이다.
# (* 정규식을 컴파일할 때 특정 옵션을 주는 것도 가능한데, 이에 대해서는 뒤에서 자세히 살펴본다.)
# (-->> * "패턴이란 정규식을 컴파일한 결과이다.")

# "정규식을 사용한 문자열 검색"
# -->> "이제 컴파일된 패턴 객체를 사용하여 문자열 검색을 수행해 보자."
# -->> "컴파일된 패턴 객체는 다음과 같은 4가지 메서드를 제공한다."
"""
# 메서드                    목적
# match() : 문자열의 처음부터 정규식과 매치되는지 확인한다.
# search() : 문자열 전체를 검색하여 정규식과 매치되는지 확인한다.
# findall() : 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.
# finditer() : 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.
"""
# match, search는 정규식과 매치될 때는 match 객체를 돌려주고,
# 매치되지 않을 때는 None을 돌려준다.
# 이들 메서드에 대한 간단한 예를 살펴보자.
# (* match 객체란 정규식의 검색 결과로 돌려주는 객체이다.)
# -->> "우선 다음과 같은 패턴을 만들어 보자."

import re
p = re.compile("[a-z]+")

"""
import re
p = re.compile("[a-z]{2,2}")
m = p.match("abcdefg")
print(m[0]) # 출력결과 Ex : ab
"""

# match
# match 메서드는 문자열의 처음부터 정규식과 매치되는지 조사한다.
# 위 패턴에 match 메서드를 수행해 보자.
"""
m = p.match("python")
print(m)
# 실행 결과 : <re.Match object; span=(0, 6), match='python'> <<-- match 객체를 돌려줌

# "python" 문자열은 [a-z]+ 정규식에 부합되므로 match 객체를 돌려준다.

m = p.match("3 python")
print(m)
# 실행 결과 : None
"""
# "3 python" 문자열은 처음에 나오는 문자 3이 정규식 [a-z]+에 부합되지 않으므로 None을 돌려준다.
# match의 결과로 match 객체 또는 None을 돌려주기 때문에 파이썬 정규식 프로그램은 보통 다음과 같은 흐름으로 작성한다.
"""
p = re.compile("[0-9]+")
m = p.match("20191274JangYuBin")
if m :
    print("Match found : ",m.group())
else:
    print("No match")
"""
# 즉 match의 결괏값이 있을 때만 그다음 작업을 수행하겠다는 것이다.

# search
# 컴파일된 파일 객체 p를 가지고 이번에는 search 메서드를 수행해보자.
"""
p = re.compile("[a-z]+")
m = p.search("python")
print(m)
# 실행 결과 : <re.Match object; span=(0, 6), match='python'>
"""
# "python" 문자열에 search 메서드를 수행하면 match 메서드를 수행했을 때와 동일하게 매치된다.
"""
p = re.compile("[a-z]+")
m = p.search("3 python")
print(m)
# 실행 결과 : <re.Match object; span=(2, 8), match='python'>
"""
# "3 python" 문자열의 첫 번째 문자는 "3"이지만 search는 문자열의 처음부터 검색하는 것이 아니라 문자열 전체를 검색하기 때문에
# "3" 이후의 "python" 문자열과 매치된다.

# -->> "이렇듯 match 메서드와 search 메서드는 문자열의 처음부터 검색할지의 여부에 따라 다르게 사용해야 한다."

# findall
# 이번에는 findall 메서드를 수행해보자.
"""
p = re.compile("[a-z]+")
result = p.findall("life is too short")
print(result)
# 출력 결과 : ['life', 'is', 'too', 'short']
"""
# "life is too short" 문자열의 "life", "is", "too", "short" 단어를 각각 [a-z]+ 정규식과 매치해서 리스트로 돌려준다.

# finditer
# 이번에는 finditer 메서드를 수행해 보자.
'''
p = re.compile("[a-z]+")
result = p.finditer("life is too short")
print(result)
# 실행 결과 : <callable_iterator object at 0x00000286FFF575B0>
for r in result: print(r)
# 실행 결과 : 
"""
<re.Match object; span=(0, 4), match='life'>
<re.Match object; span=(5, 7), match='is'>
<re.Match object; span=(8, 11), match='too'>
<re.Match object; span=(12, 17), match='short'>
"""
'''
# finditer는 findall과 동일하지만, 그 결과로 반복 가능한 객체(iterator object)를 돌려준다.
# 반복 가능한 객체가 포함하는 각각의 요소는 match 객체이다.

# match 객체의 메서드
# 자, 이제 match 메서드와 search 메서드를 수행한 결과로 돌려준 match 객체에 대해 알아보자. 앞에서 정규식을 사용한 문자열 검색을 수행하면서
# 아마도 다음과 같은 궁금중이 생겼을 것이다.

# - 어떤 문자열이 매치되었는가?
# - 매치된 문자열의 인덱스는 어디부터 어디까지인가?

# -->> "match 객체의 메서드를 사용하면 이 같은 궁금증을 해결할 수 있다. 다음 표를 보자."
"""
# 메서드                    목적
# group() : 매치된 문자열을 돌려준다.
# start() : 매치된 문자열의 시작 위치를 돌려준다.
# end() : 매치된 문자열의 끝 위치를 돌려준다.
# span() : 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 돌려준다.
"""
# 다음 예로 확인해 보자.
"""
import re
p = re.compile("[a-z]+")
m = p.match("python")
print(m.group()) # 실행 결과 : python
print(m.start()) # 실행 결과 : 0
print(m.end()) # 실행 결과 : 6
print(m.span()) # 실행 결과 : (0, 6)
"""
# 예상한 대로 결괏값이 출력되는 것을 확인할 수 있다.
# match 메서드를 수행한 결과로 돌려준 match 객체의 start()의 결괏값은 항상 0일 수 밖에 없다.
# 왜냐하면 match 메서드는 항상 문자열의 시작부터 조사하기 때문이다.

# 만약 search 메서드를 이용했다면 start() 값은 다음과 같이 다르게 나올 것이다.
# -->> "참고> search 메서드는 match 메서드와 마찬가지로 결괏값으로 match 객체를 돌려줍니다..!!"
"""
m = p.search("3 python")
print(m.group()) # 실행 결과 : python
print(m.start()) # 실행 결과 : 2
print(m.end()) # 실행 결과 : 8
print(m.span()) # 실행 결과 : (2, 8)
"""

# 점프 투 파이썬 : 모듈 단위로 수행하기
# 지금까지 우리는 re.compile을 사용하여 컴파일된 패턴 객체로 그 이후의 작업을 수행했다. re 모듈은 이것을 좀 축약한 형태로 사용할 수 있는 방법을 제공한다.
# 다음 예를 보자.
"""
p = re.compile("[a-z]+") <<-- 여기서 p는 컴파일된 패턴 객체입니다..!!
m = p.match("python") <<-- 여기서 m은 match 객체입니다..!!
print(m) # 실행 결과 : <re.Match object; span=(0, 6), match='python'>
# --->>>
m = re.match("[a-z]+", "python") <<-- 여기서 m은 match 객체입니다..!!
print(m) # 실행 결과 : <re.Match object; span=(0, 6), match='python'>
"""

# 컴파일 옵션
# 정규식을 컴파일할 때 다음 옵션을 사용할 수 있습니다.
# ....
# . 메타 문자는 줄바꿈 문자(\n)를 제외한 모든 문자와 매치되는 규칙이 있다.
# 다음 예를 보자.
"""
import re
p = re.compile("a.b")
m = p.match("a\nb")
print(m) # 실행 결과 : None <<-- 즉, 문자열과 정규식이 매치되지 않은 것입니다..!!
"""
# 정규식이 a.b인 경우는 문자열 a\nb는 매치되지 않음을 알 수 있다.
# 왜냐하면 \n은 . 메타문자와 매치되지 않기 때문이다.
# ....

# 백슬래시 문제
# 정규 표현식을 파이썬에서 사용할 때 혼란을 주는 요소가 한 가지 있는데, 바로 백슬래시(\)이다.
# 예를 들어 어떤 파일 안에 있는 "\section" 문자열을 찾기 위한 정규식을 만든다고 가정해 보자.

# \section

# 이 정규식은 \s 문자가 whitespace로 해석되어 의도한 대로 매치가 이루어지지 않는다.

# 위 표현은 다음과 동일한 의미이다.

# [ \t\n\r\f\v]ection <<-- \s 문자가 이스케이프 코드 \t, \n, \r, \f, \v로 해석됨.

# 의도한 대로 매치하고 싶다면 다음과 같이 변경해야 한다.

# \\section

# 즉 위 정규식에서 사용한 \ 문자가 문자열 자체임을 알려주기 위해 백슬래시 2개를 사용하여 이스케이프 처리를 해야 한다.

# 따라서 위 정규식을 컴파일하려면 다음과 같이 작성해야 한다.

# >>> p = re.compile("\\section")

# 그런데 여기에서 또 하나의 문제가 발견된다. 위처럼 정규식을 만들어서 컴파일하면 실제 파이썬 정규식 엔진에는 파이썬 문자열 리터럴 규칙에 따라 \\이 \로 변경되어 \section이 전달된다.
# (* 이 문제는 위와 같은 정규식을 파이썬에서 사용할 때만 발생한다(파이썬의 리터럴 규칙). 유닉스의 ....)
# 결국 정규식 엔진에 \\ 문자를 전달하려면 파이썬은 \\\\처럼 백슬래시 4개나 사용해야 한다.
# (* 정규식 엔진은 정규식을 해석하고 수행하는 모듈이다.)

# >>> p = re.compile("\\\\section")

# -->> "이렇게 해야만 원하는 결과를 얻을 수 있다. 하지만 너무 복잡하지 않은가?"

# "07-3 강력한 정규 표현식의 세계로"
# 이제 07-2에서 배우지 않은 몇몇 메타 문자의 의미를 살펴보고 그룹(Group)을 만드는 법, 전방 탐색 등 더욱 강력한 정규 표현식에 대햇 살펴보자.

# 메타 문자
# 아직 살펴보지 않은 메타 문자에 대해서 모두 살펴보자.
# 여기에서 다룰 메타 문자는 앞에서 살펴본 메타 문자와 성격이 조금 다르다.
# 앞에서 살펴본 +, *, [], {} 등의 메타문자는 매치가 진행될 때 현재 매치되고 있는 문자열의 위치가 변경된다(-->> "보통 소비된다고 표현한다.").
# 하지만 이와 달리 문자열을 소비시키지 않는 메타 문자도 있다.
# 이번에는 이런 문자열 소비가 없는(zero - width assertions) 메타 문자에 대해 살펴보자.

# |
# | 메타 문자는 or과 동일한 의미로 사용된다. A|B라는 정규식이 있다면 A 또는 B라는 의미가 된다.

p = re.compile("Crow|Servo") # <<-- 즉, Crow 문자열 아니면 Servo 문자열에 매칭시켜쥼..!!
m = p.match("CrowHello")
print(m[0]) # 출력 결과 Ex : Crow
print(m) # 출력 결과 Ex : <re.Match object; span=(0, 4), match='Crow'>

# ^ 
# -->> "^ 메타 문자는 문자열의 맨 처음과 일치함을 의미한다." (단, 문자 클래스 [] 안에서 사용할 경우 '반대'의 의미를 가집니다..!!)
"""
print(re.search("^Life", "Life is too short"))
# 출력 결과 : <re.Match object; span=(0, 4), match='Life'>
print(re.search("^Life", "My Life"))
# 출력 결과 : None
"""
# "^Life" 정규식은 Life 문자열이 처음에 온 경우에는 매치하지만 처음 위치가 아닌 경우에는 매치되지 않음을 알 수 있다.

# $ 
# $ 메타 문자는 ^ 메타 문자와 반대의 경우이다. 즉 $는 문자열의 끝과 매치함을 의미한다.
# 다음 예를 보자.
"""
print(re.search("short$", "Life is too short"))
# 출력 결과 : <re.Match object; span=(12, 17), match='short'>
print(re.search("short$", "Life is too short, you need python"))
# 출력 결과 : None
"""
# "short$" 정규식은 검색할 문자열이 short으로 끝난 경우에는 매치되지만 그 이외의 경우에는 매치되지 않음을 알 수 있다.
# (* ^ 또는 & 문자를 메타 문자가 아닌 문자 그 자체로 매치하고 싶은 경우에는 \^, \$ 로 사용하면 된다.)

# 그루핑
# ABC 문자열이 계속해서 반복되는지 조사하는 정규식을 작성하고 싶다고 하자. 어떻게 해야 할까?
# 지금까지 공부한 내용으로는 위 정규식을 작성할 수 없다.
# 이럴 때 필요한 것이 바로 그루핑(Grouping) 이다.

# 위 경우는 다음처럼 그루핑을 사용하여 작성할 수 있다.

# (ABC)+

# 그룹을 만들어주는 메타 문자는 바로 ( ) 이다.
"""
p = re.compile("(ABC)+")
m = p.search("ABCABCABC OK?")
print(m) # 출력 결과 : <re.Match object; span=(0, 9), match='ABCABCABC'>
print(m.group()) # 출력 결과 : ABCABCABC
# 참고> match 객체의 메서드 중 하나인 group() 메서드는 매칭된 문자열을 반환해주는 함수입니다..!!
"""

# ....

# 문자열 바꾸기
# sub 메서드를 이용하면 정규식과 매치되는 부분을 다른 문자로 쉽게 바꿀 수 있다.
# 다음 예를 보자.

p = re.compile("blue|while|red") # <<-- 즉, 세 개의 문자열 중 하나가 나타나면 매칭해달라는 의지가 담긴 수행문입니다..!!
print(p.sub("colour", "blue socks and red shoes"))
# 출력 결과 Ex : colour socks and colour shoes

# sub 메서드의 첫 번째 매개변수는 '바꿀 문자열(replacement)'이 되고,
# 두 번째 매개변수는 '대상 문자열'이 된다.
# 위 예에서 볼 수 있듯이
# blue 또는 white 또는 red라는 문자열이 colour라는 문자열로 바뀌는 것을 확인할 수 있다..!!

# 그런데 딱 한 번만 바꾸고 싶은 경우도 있다.
# 이렇게 바꾸기 횟수를 제어하려면 다음과 같이 세 번째 매개변수로 count 값을 넘기면 된다.

print(p.sub("colour", "blue socks and white shoes", count = 1)) # 참고 > 여기서 p가 의미하는 바는 '컴파일된 패턴 객체'입니다..!!
# 출력 결과 Ex : colour socks and white shoes
