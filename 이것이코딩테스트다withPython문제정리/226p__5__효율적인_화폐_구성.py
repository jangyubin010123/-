# <5> 효율적인 화폐 구성

# my solution
"""
n, m = map(int, input().split())
array = []
for i in range(0,n):
    array.append(int(input()))
# print(array)
d = [10001] * (m + 1)
d[0] = 0

for money in array:
    for j in range(money,m + 1):
        d[j] = min(d[j], d[j -money] + 1)

if d[m] == 10001:
    print(-1)
else:
    print(d[m])
"""
# 문제 해설
# 이 문제는 그리디에서 다루었던 거스름돈 문제와 거의 동일하다. 단지 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다.
# 그렇기 때문에 그리디 알고리즘을 사용했던 예시처럼 매번 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없고 다이나믹 프로그래밍을 이용해야 한다.
# 이번 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.
# 금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i), 화폐의 단위를 k라고 했을 때 다음과 같이 점화식을 작성할 수 있다.
# a(i-k)는 금액 (i-k)를 만들 수 있는 최소한의 화폐 개수를 의미한다.
# * a(i-k)를 만드는 방법이 존재하는 경우, a(i) = min(a(i), a(i-k) + 1)
# * a(i-k)를 만드는 방법이 존재하지 않는 경우, a(i) = 10,001
# 이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다.
# 실제로 문제를 풀기 위해서는 가장 먼저 K의 크기만큼 리스트를 할당한다.
# 이후에 각 인덱스를 '금액'으로 고려하여 메모이제이션을 진행한다.
# 예를 들어 N = 3, K = 7이고, 각 화폐의 단위가 2, 3, 5인 경우를 생각해보자.
# <step 0> "초기화" : 각 인덱스에 해당하는 값으로 10,001을 설정한다. 10,001은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미이다.
# 필자는 M의 최대 크기가 10,000이므로 불가능한 수로 10,001이라는 값을 설정했으며 이보다 더 큰 수여도 상관없다.
# 또한 0원인 경우, 화폐를 하나도 사용하지 않았을 때 만들 수 있으므로 값으로 0을 설정한다.
# 따라서 초기 리스트의 값은 다음과 같다.
# <step 1> "화폐 단위 : 2, 3, 5" : 가장 먼저 화폐 단위인 2부터 확인한다. 앞서 언급한 점화식에 따라 다음과 같이 리스트가 갱신된다.
# 예를 들어 인덱스 2인 경우 1이라는 값을 가지는데, 이는 2원짜리 화폐 하나를 이용하여 2원을 만들 수 있다는 의미이다. 다시 말해, a(2) = a(0) + 1이다.
# 인덱스 4의 경우 2라는 값을 가지는데, .... 다시 말해 a(4) = a(2) + 1이다. 몇 인덱스의 경우 10,001의 값을 그대로 가지는데, 이는 2원짜리 화폐를 가지고 구성할 수 없는 금액이기 때문이다.
# 예를 들어 인덱스 3의 경우 인덱스 1의 값이 10,001이므로 마찬가지로 10,001의 값을 가진다.
# <step 2> "화폐 단위 : 2, 3, 5" : 이어서 화폐 단위 3을 확인한다. 앞서 언급한 점화식에 따라서 값을 도출하면 다음과 같이 리스트가 갱신된다. 예를 들어 a(5) = a(2) + 1로 2라는 값을 가진다. 이것은 2원짜리 화폐 1개, 3원짜리 화폐 1개로 (2 + 3) = 5원을 만들 수 있다는 의미가 된다.
# <step 3> "화폐 단위 : 2, 3, 5" : 이어서 화폐 단위 5을 확인한다. ....
# ....

# 8-8.py 답안 예시
# 정수 N, M을 입력받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보 입력받기
array = []
for i in range(n):
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        if d[j - array[i]] != 10001: # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[m])
