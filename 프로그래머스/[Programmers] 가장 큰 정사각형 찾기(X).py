# another solution

# another thoughts : "가장 큰 정사각형 찾기" 문제는 동적 프로그래밍으로 풀지 않으면 효율성 테스트에서 통과되지 않는다..!!
# 처음에 동적 프로그래밍으로 풀어야 한다는 생각을 하기까지 시간이 좀 걸려서 그 과정까지 함께 설명해보려고 한다.

# "왜 동적 프로그래밍 문제인가?"
# 그 이유는 아래와 같이 크게 두 가지이다.
# 1. 점점 값을 쌓아가면서 풀어야함
# 2. dp를 이용하지 않는다면 3중 반복문을 써야함..!!

# "동적 프로그래밍(DP)인 이유"
# * DP를 사용하지 않는다면 3중 반복문을 사용해야 한다.
# -->> 크기가 4인 가능한 정사각형을 확인하는 데 2중 포문 + 가능한 정사각형의 크기를 키워가는 데 반복문 한 겹 더..!!
# -->> 효율성 테스트 Fail
# -->> 효율성 테스트를 실행해보지 않아도 board의 최대 행, 열의 크기가 1000이니까 3중 포문시 1000000000으로 파이썬이 1초에 가능한 연산 수가 대략 2천만 임을 고려했을 때 5초 정도가 걸릴 것이다..!!
# (알고리즘 문제의 대부분은 제한시간이 2 ~ 3 초이다..!!)

# "DP를 이용한 풀이"
# * 2중 포문을 이용해서 원소 하나하나에 방문한다.
# * 현재의 위치에서 가능한 최대 크기의 정사각형의 한 변의 길이를 dp에 저장한다.
# * 아래와 같은 과정을 하나씩 해보면 알겠지만, "현재의 위치에서 가능한 최대 크기의 정사각형의 한 변의 길이"는 현재 위치가 [i][j]라면 dp[i-1][j-1], dp[i-1][j], dp[i][j-1] 이렇게 세 값을 비교했을 때 가장 작은 값에 1을 더한 값이다..!!(단, 현재 위치의 board의 값이 1일 때..!!)

# "풀이 방법"
# ....

# "코드"

def solution(board):
    m = len(board)
    n = len(board[0])

    # dp 준비
    # 오른쪽 아래로 가면서 값을 쌓아줄 것이기 때문에 맨 윗줄과 맨 왼쪽 줄은 비교를 위해 고정한다..!!
    dp = [[0] * n for _ in range(m)]
    dp[0] = board[0]
    for i in range(1, m):
        dp[i][0] = board[i][0]
    
    # 2중 포문으로 연산
    for i in range(1, m):
        for j in range(1, n):
            if board[i][j] == 1:
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
    
    # 최대 넓이 구하기
    answer = 0
    for i in range(m):
        for j in range(n):
            if answer < dp[i][j]:
                answer = dp[i][j]
    
    return (answer**2)

print(solution([[1,1,1], [1,1,1], [1,1,1]]))
